diff -cN ../opencv_unmod/modules/objdetect/src/cascadedetect.cpp ../opencv/modules/objdetect/src/cascadedetect.cpp
*** ../opencv_unmod/modules/objdetect/src/cascadedetect.cpp	2016-04-29 00:17:16.523389999 +0000
--- ../opencv/modules/objdetect/src/cascadedetect.cpp	2016-04-29 00:27:20.231389999 +0000
***************
*** 1,3 ****
--- 1,4 ----
+ #include "replaces.hpp"
  /*M///////////////////////////////////////////////////////////////////////////////////////
  //
  //  IMPORTANT: READ BEFORE DOWNLOADING, COPYING, INSTALLING OR USING.
***************
*** 10,16 ****
  //                           License Agreement
  //                For Open Source Computer Vision Library
  //
! // Copyright (C) 2008-2013, Itseez Inc., all rights reserved.
  // Third party copyrights are property of their respective owners.
  //
  // Redistribution and use in source and binary forms, with or without modification,
--- 11,17 ----
  //                           License Agreement
  //                For Open Source Computer Vision Library
  //
! // Copyright (C) cascadedetectcpp_INTEGER_13_1_2008-cascadedetectcpp_INTEGER_13_2_2013, Itseez Inc., all rights reserved.
  // Third party copyrights are property of their respective owners.
  //
  // Redistribution and use in source and binary forms, with or without modification,
***************
*** 51,382 ****
  
  template<typename _Tp> void copyVectorToUMat(const std::vector<_Tp>& v, UMat& um)
  {
!     if(v.empty())
!         um.release();
!     Mat(1, (int)(v.size()*sizeof(v[0])), CV_8U, (void*)&v[0]).copyTo(um);
  }
  
  void groupRectangles(std::vector<Rect>& rectList, int groupThreshold, double eps,
!                      std::vector<int>* weights, std::vector<double>* levelWeights)
  {
!     if( groupThreshold <= 0 || rectList.empty() )
!     {
!         if( weights )
!         {
!             size_t i, sz = rectList.size();
!             weights->resize(sz);
!             for( i = 0; i < sz; i++ )
!                 (*weights)[i] = 1;
!         }
!         return;
!     }
! 
!     std::vector<int> labels;
!     int nclasses = partition(rectList, labels, SimilarRects(eps));
! 
!     std::vector<Rect> rrects(nclasses);
!     std::vector<int> rweights(nclasses, 0);
!     std::vector<int> rejectLevels(nclasses, 0);
!     std::vector<double> rejectWeights(nclasses, DBL_MIN);
!     int i, j, nlabels = (int)labels.size();
!     for( i = 0; i < nlabels; i++ )
!     {
!         int cls = labels[i];
!         rrects[cls].x += rectList[i].x;
!         rrects[cls].y += rectList[i].y;
!         rrects[cls].width += rectList[i].width;
!         rrects[cls].height += rectList[i].height;
!         rweights[cls]++;
!     }
! 
!     bool useDefaultWeights = false;
! 
!     if ( levelWeights && weights && !weights->empty() && !levelWeights->empty() )
!     {
!         for( i = 0; i < nlabels; i++ )
!         {
!             int cls = labels[i];
!             if( (*weights)[i] > rejectLevels[cls] )
!             {
!                 rejectLevels[cls] = (*weights)[i];
!                 rejectWeights[cls] = (*levelWeights)[i];
!             }
!             else if( ( (*weights)[i] == rejectLevels[cls] ) && ( (*levelWeights)[i] > rejectWeights[cls] ) )
!                 rejectWeights[cls] = (*levelWeights)[i];
!         }
!     }
!     else
!         useDefaultWeights = true;
! 
!     for( i = 0; i < nclasses; i++ )
!     {
!         Rect r = rrects[i];
!         float s = 1.f/rweights[i];
!         rrects[i] = Rect(saturate_cast<int>(r.x*s),
!              saturate_cast<int>(r.y*s),
!              saturate_cast<int>(r.width*s),
!              saturate_cast<int>(r.height*s));
!     }
! 
!     rectList.clear();
!     if( weights )
!         weights->clear();
!     if( levelWeights )
!         levelWeights->clear();
! 
!     for( i = 0; i < nclasses; i++ )
!     {
!         Rect r1 = rrects[i];
!         int n1 = rweights[i];
!         double w1 = rejectWeights[i];
!         int l1 = rejectLevels[i];
! 
!         // filter out rectangles which don't have enough similar rectangles
!         if( n1 <= groupThreshold )
!             continue;
!         // filter out small face rectangles inside large rectangles
!         for( j = 0; j < nclasses; j++ )
!         {
!             int n2 = rweights[j];
! 
!             if( j == i || n2 <= groupThreshold )
!                 continue;
!             Rect r2 = rrects[j];
! 
!             int dx = saturate_cast<int>( r2.width * eps );
!             int dy = saturate_cast<int>( r2.height * eps );
! 
!             if( i != j &&
!                 r1.x >= r2.x - dx &&
!                 r1.y >= r2.y - dy &&
!                 r1.x + r1.width <= r2.x + r2.width + dx &&
!                 r1.y + r1.height <= r2.y + r2.height + dy &&
!                 (n2 > std::max(3, n1) || n1 < 3) )
!                 break;
!         }
! 
!         if( j == nclasses )
!         {
!             rectList.push_back(r1);
!             if( weights )
!                 weights->push_back(useDefaultWeights ? n1 : l1);
!             if( levelWeights )
!                 levelWeights->push_back(w1);
!         }
!     }
  }
  
  class MeanshiftGrouping
  {
  public:
!     MeanshiftGrouping(const Point3d& densKer, const std::vector<Point3d>& posV,
!         const std::vector<double>& wV, double eps, int maxIter = 20)
!     {
!         densityKernel = densKer;
!         weightsV = wV;
!         positionsV = posV;
!         positionsCount = (int)posV.size();
!         meanshiftV.resize(positionsCount);
!         distanceV.resize(positionsCount);
!         iterMax = maxIter;
!         modeEps = eps;
! 
!         for (unsigned i = 0; i<positionsV.size(); i++)
!         {
!             meanshiftV[i] = getNewValue(positionsV[i]);
!             distanceV[i] = moveToMode(meanshiftV[i]);
!             meanshiftV[i] -= positionsV[i];
!         }
!     }
! 
!     void getModes(std::vector<Point3d>& modesV, std::vector<double>& resWeightsV, const double eps)
!     {
!         for (size_t i=0; i <distanceV.size(); i++)
!         {
!             bool is_found = false;
!             for(size_t j=0; j<modesV.size(); j++)
!             {
!                 if ( getDistance(distanceV[i], modesV[j]) < eps)
!                 {
!                     is_found=true;
!                     break;
!                 }
!             }
!             if (!is_found)
!             {
!                 modesV.push_back(distanceV[i]);
!             }
!         }
! 
!         resWeightsV.resize(modesV.size());
! 
!         for (size_t i=0; i<modesV.size(); i++)
!         {
!             resWeightsV[i] = getResultWeight(modesV[i]);
!         }
!     }
  
  protected:
!     std::vector<Point3d> positionsV;
!     std::vector<double> weightsV;
  
!     Point3d densityKernel;
!     int positionsCount;
  
!     std::vector<Point3d> meanshiftV;
!     std::vector<Point3d> distanceV;
!     int iterMax;
!     double modeEps;
! 
!     Point3d getNewValue(const Point3d& inPt) const
!     {
!         Point3d resPoint(.0);
!         Point3d ratPoint(.0);
!         for (size_t i=0; i<positionsV.size(); i++)
!         {
!             Point3d aPt= positionsV[i];
!             Point3d bPt = inPt;
!             Point3d sPt = densityKernel;
! 
!             sPt.x *= std::exp(aPt.z);
!             sPt.y *= std::exp(aPt.z);
! 
!             aPt.x /= sPt.x;
!             aPt.y /= sPt.y;
!             aPt.z /= sPt.z;
! 
!             bPt.x /= sPt.x;
!             bPt.y /= sPt.y;
!             bPt.z /= sPt.z;
! 
!             double w = (weightsV[i])*std::exp(-((aPt-bPt).dot(aPt-bPt))/2)/std::sqrt(sPt.dot(Point3d(1,1,1)));
! 
!             resPoint += w*aPt;
! 
!             ratPoint.x += w/sPt.x;
!             ratPoint.y += w/sPt.y;
!             ratPoint.z += w/sPt.z;
!         }
!         resPoint.x /= ratPoint.x;
!         resPoint.y /= ratPoint.y;
!         resPoint.z /= ratPoint.z;
!         return resPoint;
!     }
! 
!     double getResultWeight(const Point3d& inPt) const
!     {
!         double sumW=0;
!         for (size_t i=0; i<positionsV.size(); i++)
!         {
!             Point3d aPt = positionsV[i];
!             Point3d sPt = densityKernel;
! 
!             sPt.x *= std::exp(aPt.z);
!             sPt.y *= std::exp(aPt.z);
! 
!             aPt -= inPt;
! 
!             aPt.x /= sPt.x;
!             aPt.y /= sPt.y;
!             aPt.z /= sPt.z;
! 
!             sumW+=(weightsV[i])*std::exp(-(aPt.dot(aPt))/2)/std::sqrt(sPt.dot(Point3d(1,1,1)));
!         }
!         return sumW;
!     }
! 
!     Point3d moveToMode(Point3d aPt) const
!     {
!         Point3d bPt;
!         for (int i = 0; i<iterMax; i++)
!         {
!             bPt = aPt;
!             aPt = getNewValue(bPt);
!             if ( getDistance(aPt, bPt) <= modeEps )
!             {
!                 break;
!             }
!         }
!         return aPt;
!     }
! 
!     double getDistance(Point3d p1, Point3d p2) const
!     {
!         Point3d ns = densityKernel;
!         ns.x *= std::exp(p2.z);
!         ns.y *= std::exp(p2.z);
!         p2 -= p1;
!         p2.x /= ns.x;
!         p2.y /= ns.y;
!         p2.z /= ns.z;
!         return p2.dot(p2);
!     }
  };
  //new grouping function with using meanshift
  static void groupRectangles_meanshift(std::vector<Rect>& rectList, double detectThreshold, std::vector<double>* foundWeights,
!                                       std::vector<double>& scales, Size winDetSize)
  {
!     int detectionCount = (int)rectList.size();
!     std::vector<Point3d> hits(detectionCount), resultHits;
!     std::vector<double> hitWeights(detectionCount), resultWeights;
!     Point2d hitCenter;
! 
!     for (int i=0; i < detectionCount; i++)
!     {
!         hitWeights[i] = (*foundWeights)[i];
!         hitCenter = (rectList[i].tl() + rectList[i].br())*(0.5); //center of rectangles
!         hits[i] = Point3d(hitCenter.x, hitCenter.y, std::log(scales[i]));
!     }
! 
!     rectList.clear();
!     if (foundWeights)
!         foundWeights->clear();
! 
!     double logZ = std::log(1.3);
!     Point3d smothing(8, 16, logZ);
! 
!     MeanshiftGrouping msGrouping(smothing, hits, hitWeights, 1e-5, 100);
! 
!     msGrouping.getModes(resultHits, resultWeights, 1);
! 
!     for (unsigned i=0; i < resultHits.size(); ++i)
!     {
! 
!         double scale = std::exp(resultHits[i].z);
!         hitCenter.x = resultHits[i].x;
!         hitCenter.y = resultHits[i].y;
!         Size s( int(winDetSize.width * scale), int(winDetSize.height * scale) );
!         Rect resultRect( int(hitCenter.x-s.width/2), int(hitCenter.y-s.height/2),
!             int(s.width), int(s.height) );
! 
!         if (resultWeights[i] > detectThreshold)
!         {
!             rectList.push_back(resultRect);
!             foundWeights->push_back(resultWeights[i]);
!         }
!     }
  }
  
  void groupRectangles(std::vector<Rect>& rectList, int groupThreshold, double eps)
  {
!     groupRectangles(rectList, groupThreshold, eps, 0, 0);
  }
  
  void groupRectangles(std::vector<Rect>& rectList, std::vector<int>& weights, int groupThreshold, double eps)
  {
!     groupRectangles(rectList, groupThreshold, eps, &weights, 0);
  }
  //used for cascade detection algorithm for ROC-curve calculating
  void groupRectangles(std::vector<Rect>& rectList, std::vector<int>& rejectLevels,
!                      std::vector<double>& levelWeights, int groupThreshold, double eps)
  {
!     groupRectangles(rectList, groupThreshold, eps, &rejectLevels, &levelWeights);
  }
  //can be used for HOG detection algorithm only
  void groupRectangles_meanshift(std::vector<Rect>& rectList, std::vector<double>& foundWeights,
!                                std::vector<double>& foundScales, double detectThreshold, Size winDetSize)
  {
!     groupRectangles_meanshift(rectList, detectThreshold, &foundWeights, foundScales, winDetSize);
  }
  
  
--- 52,383 ----
  
  template<typename _Tp> void copyVectorToUMat(const std::vector<_Tp>& v, UMat& um)
  {
! if(v.empty())
! um.release();
! Mat(cascadedetectcpp_INTEGER_56_1_1, (int)(v.size()*sizeof(v[cascadedetectcpp_INTEGER_56_2_0])), CV_8U, (void*)&v[cascadedetectcpp_INTEGER_56_3_0]).copyTo(um);
  }
  
  void groupRectangles(std::vector<Rect>& rectList, int groupThreshold, double eps,
! std::vector<int>* weights, std::vector<double>* levelWeights)
  {
! if( groupThreshold <= cascadedetectcpp_INTEGER_62_1_0 || rectList.empty() )
! {
! if( weights )
! {
! size_t i, sz = rectList.size();
! weights->resize(sz);
! for( i = cascadedetectcpp_INTEGER_68_1_0; i < sz; i+=cascadedetectcpp_INTEGER_68_2_1 )
! (*weights)[i] = cascadedetectcpp_INTEGER_69_1_1;
! }
! return;
! }
! 
! std::vector<int> labels;
! int nclasses = partition(rectList, labels, SimilarRects(eps));
! 
! std::vector<Rect> rrects(nclasses);
! std::vector<int> rweights(nclasses, cascadedetectcpp_INTEGER_78_1_0);
! std::vector<int> rejectLevels(nclasses, cascadedetectcpp_INTEGER_79_1_0);
! std::vector<double> rejectWeights(nclasses, DBL_MIN);
! int i, j, nlabels = (int)labels.size();
! for( i = cascadedetectcpp_INTEGER_82_1_0; i < nlabels; i+=cascadedetectcpp_INTEGER_82_2_1 )
! {
! int cls = labels[i];
! rrects[cls].x += rectList[i].x;
! rrects[cls].y += rectList[i].y;
! rrects[cls].width += rectList[i].width;
! rrects[cls].height += rectList[i].height;
! rweights[cls]+=cascadedetectcpp_INTEGER_89_1_1;
! }
! 
! bool useDefaultWeights = false;
! 
! if ( levelWeights && weights && !weights->empty() && !levelWeights->empty() )
! {
! for( i = cascadedetectcpp_INTEGER_96_1_0; i < nlabels; i+=cascadedetectcpp_INTEGER_96_2_1 )
! {
! int cls = labels[i];
! if( (*weights)[i] > rejectLevels[cls] )
! {
! rejectLevels[cls] = (*weights)[i];
! rejectWeights[cls] = (*levelWeights)[i];
! }
! else if( ( (*weights)[i] == rejectLevels[cls] ) && ( (*levelWeights)[i] > rejectWeights[cls] ) )
! rejectWeights[cls] = (*levelWeights)[i];
! }
! }
! else
! useDefaultWeights = true;
! 
! for( i = cascadedetectcpp_INTEGER_111_1_0; i < nclasses; i+=cascadedetectcpp_INTEGER_111_2_1 )
! {
! Rect r = rrects[i];
! float s = 1.f/rweights[i];
! rrects[i] = Rect(saturate_cast<int>(r.x*s),
! saturate_cast<int>(r.y*s),
! saturate_cast<int>(r.width*s),
! saturate_cast<int>(r.height*s));
! }
! 
! rectList.clear();
! if( weights )
! weights->clear();
! if( levelWeights )
! levelWeights->clear();
! 
! for( i = cascadedetectcpp_INTEGER_127_1_0; i < nclasses; i+=cascadedetectcpp_INTEGER_127_2_1 )
! {
! Rect r1 = rrects[i];
! int n1 = rweights[i];
! double w1 = rejectWeights[i];
! int l1 = rejectLevels[i];
! 
! // filter out rectangles which don't have enough similar rectangles
! if( n1 <= groupThreshold )
! continue;
! // filter out small face rectangles inside large rectangles
! for( j = cascadedetectcpp_INTEGER_138_1_0; j < nclasses; j+=cascadedetectcpp_INTEGER_138_2_1 )
! {
! int n2 = rweights[j];
! 
! if( j == i || n2 <= groupThreshold )
! continue;
! Rect r2 = rrects[j];
! 
! int dx = saturate_cast<int>( r2.width * eps );
! int dy = saturate_cast<int>( r2.height * eps );
! 
! if( i != j &&
! r1.x >= r2.x - dx &&
! r1.y >= r2.y - dy &&
! r1.x + r1.width <= r2.x + r2.width + dx &&
! r1.y + r1.height <= r2.y + r2.height + dy &&
! (n2 > std::max(cascadedetectcpp_INTEGER_154_1_3, n1) || n1 < cascadedetectcpp_INTEGER_154_2_3) )
! break;
! }
! 
! if( j == nclasses )
! {
! rectList.push_back(r1);
! if( weights )
! weights->push_back(useDefaultWeights ? n1 : l1);
! if( levelWeights )
! levelWeights->push_back(w1);
! }
! }
  }
  
  class MeanshiftGrouping
  {
  public:
! MeanshiftGrouping(const Point3d& densKer, const std::vector<Point3d>& posV,
! const std::vector<double>& wV, double eps, int maxIter = cascadedetectcpp_INTEGER_173_1_20)
! {
! densityKernel = densKer;
! weightsV = wV;
! positionsV = posV;
! positionsCount = (int)posV.size();
! meanshiftV.resize(positionsCount);
! distanceV.resize(positionsCount);
! iterMax = maxIter;
! modeEps = eps;
! 
! for (unsigned i = cascadedetectcpp_INTEGER_184_1_0; i<positionsV.size(); i+=cascadedetectcpp_INTEGER_184_2_1)
! {
! meanshiftV[i] = getNewValue(positionsV[i]);
! distanceV[i] = moveToMode(meanshiftV[i]);
! meanshiftV[i] -= positionsV[i];
! }
! }
! 
! void getModes(std::vector<Point3d>& modesV, std::vector<double>& resWeightsV, const double eps)
! {
! for (size_t i=cascadedetectcpp_INTEGER_194_1_0; i <distanceV.size(); i+=cascadedetectcpp_INTEGER_194_2_1)
! {
! bool is_found = false;
! for(size_t j=cascadedetectcpp_INTEGER_197_1_0; j<modesV.size(); j+=cascadedetectcpp_INTEGER_197_2_1)
! {
! if ( getDistance(distanceV[i], modesV[j]) < eps)
! {
! is_found=true;
! break;
! }
! }
! if (!is_found)
! {
! modesV.push_back(distanceV[i]);
! }
! }
! 
! resWeightsV.resize(modesV.size());
! 
! for (size_t i=cascadedetectcpp_INTEGER_213_1_0; i<modesV.size(); i+=cascadedetectcpp_INTEGER_213_2_1)
! {
! resWeightsV[i] = getResultWeight(modesV[i]);
! }
! }
  
  protected:
! std::vector<Point3d> positionsV;
! std::vector<double> weightsV;
! 
! Point3d densityKernel;
! int positionsCount;
! 
! std::vector<Point3d> meanshiftV;
! std::vector<Point3d> distanceV;
! int iterMax;
! double modeEps;
! 
! Point3d getNewValue(const Point3d& inPt) const
! {
! Point3d resPoint(.0);
! Point3d ratPoint(.0);
! for (size_t i=cascadedetectcpp_INTEGER_235_1_0; i<positionsV.size(); i+=cascadedetectcpp_INTEGER_235_2_1)
! {
! Point3d aPt= positionsV[i];
! Point3d bPt = inPt;
! Point3d sPt = densityKernel;
! 
! sPt.x *= std::exp(aPt.z);
! sPt.y *= std::exp(aPt.z);
! 
! aPt.x /= sPt.x;
! aPt.y /= sPt.y;
! aPt.z /= sPt.z;
! 
! bPt.x /= sPt.x;
! bPt.y /= sPt.y;
! bPt.z /= sPt.z;
  
! double w = (weightsV[i])*std::exp(-((aPt-bPt).dot(aPt-bPt))/cascadedetectcpp_INTEGER_252_1_2)/std::sqrt(sPt.dot(Point3d(cascadedetectcpp_INTEGER_252_2_1,cascadedetectcpp_INTEGER_252_3_1,cascadedetectcpp_INTEGER_252_4_1)));
  
! resPoint += w*aPt;
! 
! ratPoint.x += w/sPt.x;
! ratPoint.y += w/sPt.y;
! ratPoint.z += w/sPt.z;
! }
! resPoint.x /= ratPoint.x;
! resPoint.y /= ratPoint.y;
! resPoint.z /= ratPoint.z;
! return resPoint;
! }
! 
! double getResultWeight(const Point3d& inPt) const
! {
! double sumW=cascadedetectcpp_INTEGER_268_1_0;
! for (size_t i=cascadedetectcpp_INTEGER_269_1_0; i<positionsV.size(); i+=cascadedetectcpp_INTEGER_269_2_1)
! {
! Point3d aPt = positionsV[i];
! Point3d sPt = densityKernel;
! 
! sPt.x *= std::exp(aPt.z);
! sPt.y *= std::exp(aPt.z);
! 
! aPt -= inPt;
! 
! aPt.x /= sPt.x;
! aPt.y /= sPt.y;
! aPt.z /= sPt.z;
! 
! sumW+=(weightsV[i])*std::exp(-(aPt.dot(aPt))/cascadedetectcpp_INTEGER_283_1_2)/std::sqrt(sPt.dot(Point3d(cascadedetectcpp_INTEGER_283_2_1,cascadedetectcpp_INTEGER_283_3_1,cascadedetectcpp_INTEGER_283_4_1)));
! }
! return sumW;
! }
! 
! Point3d moveToMode(Point3d aPt) const
! {
! Point3d bPt;
! for (int i = cascadedetectcpp_INTEGER_291_1_0; i<iterMax; i+=cascadedetectcpp_INTEGER_291_2_1)
! {
! bPt = aPt;
! aPt = getNewValue(bPt);
! if ( getDistance(aPt, bPt) <= modeEps )
! {
! break;
! }
! }
! return aPt;
! }
! 
! double getDistance(Point3d p1, Point3d p2) const
! {
! Point3d ns = densityKernel;
! ns.x *= std::exp(p2.z);
! ns.y *= std::exp(p2.z);
! p2 -= p1;
! p2.x /= ns.x;
! p2.y /= ns.y;
! p2.z /= ns.z;
! return p2.dot(p2);
! }
  };
  //new grouping function with using meanshift
  static void groupRectangles_meanshift(std::vector<Rect>& rectList, double detectThreshold, std::vector<double>* foundWeights,
! std::vector<double>& scales, Size winDetSize)
! {
! int detectionCount = (int)rectList.size();
! std::vector<Point3d> hits(detectionCount), resultHits;
! std::vector<double> hitWeights(detectionCount), resultWeights;
! Point2d hitCenter;
! 
! for (int i=cascadedetectcpp_INTEGER_324_1_0; i < detectionCount; i+=cascadedetectcpp_INTEGER_324_2_1)
! {
! hitWeights[i] = (*foundWeights)[i];
! hitCenter = (rectList[i].tl() + rectList[i].br())*(0.5); //center of rectangles
! hits[i] = Point3d(hitCenter.x, hitCenter.y, std::log(scales[i]));
! }
! 
! rectList.clear();
! if (foundWeights)
! foundWeights->clear();
! 
! double logZ = std::log(1.3);
! Point3d smothing(cascadedetectcpp_INTEGER_336_1_8, cascadedetectcpp_INTEGER_336_2_16, logZ);
! 
! MeanshiftGrouping msGrouping(smothing, hits, hitWeights, 1e-5, cascadedetectcpp_INTEGER_338_1_100);
! 
! msGrouping.getModes(resultHits, resultWeights, cascadedetectcpp_INTEGER_340_1_1);
! 
! for (unsigned i=cascadedetectcpp_INTEGER_342_1_0; i < resultHits.size(); ++i)
! {
! 
! double scale = std::exp(resultHits[i].z);
! hitCenter.x = resultHits[i].x;
! hitCenter.y = resultHits[i].y;
! Size s( int(winDetSize.width * scale), int(winDetSize.height * scale) );
! Rect resultRect( int(hitCenter.x-s.width/cascadedetectcpp_INTEGER_349_1_2), int(hitCenter.y-s.height/cascadedetectcpp_INTEGER_349_2_2),
! int(s.width), int(s.height) );
! 
! if (resultWeights[i] > detectThreshold)
  {
! rectList.push_back(resultRect);
! foundWeights->push_back(resultWeights[i]);
! }
! }
  }
  
  void groupRectangles(std::vector<Rect>& rectList, int groupThreshold, double eps)
  {
! groupRectangles(rectList, groupThreshold, eps, cascadedetectcpp_INTEGER_362_1_0, cascadedetectcpp_INTEGER_362_2_0);
  }
  
  void groupRectangles(std::vector<Rect>& rectList, std::vector<int>& weights, int groupThreshold, double eps)
  {
! groupRectangles(rectList, groupThreshold, eps, &weights, cascadedetectcpp_INTEGER_367_1_0);
  }
  //used for cascade detection algorithm for ROC-curve calculating
  void groupRectangles(std::vector<Rect>& rectList, std::vector<int>& rejectLevels,
! std::vector<double>& levelWeights, int groupThreshold, double eps)
  {
! groupRectangles(rectList, groupThreshold, eps, &rejectLevels, &levelWeights);
  }
  //can be used for HOG detection algorithm only
  void groupRectangles_meanshift(std::vector<Rect>& rectList, std::vector<double>& foundWeights,
! std::vector<double>& foundScales, double detectThreshold, Size winDetSize)
  {
! groupRectangles_meanshift(rectList, detectThreshold, &foundWeights, foundScales, winDetSize);
  }
  
  
***************
*** 384,561 ****
  
  bool FeatureEvaluator::read(const FileNode&, Size _origWinSize)
  {
!     origWinSize = _origWinSize;
!     localSize = lbufSize = Size(0, 0);
!     if (scaleData.empty())
!         scaleData = makePtr<std::vector<ScaleData> >();
!     else
!         scaleData->clear();
!     return true;
  }
  
  Ptr<FeatureEvaluator> FeatureEvaluator::clone() const { return Ptr<FeatureEvaluator>(); }
! int FeatureEvaluator::getFeatureType() const {return -1;}
  bool FeatureEvaluator::setWindow(Point, int) { return true; }
  void FeatureEvaluator::getUMats(std::vector<UMat>& bufs)
  {
!     if (!(sbufFlag & USBUF_VALID))
!     {
!         sbuf.copyTo(usbuf);
!         sbufFlag |= USBUF_VALID;
!     }
! 
!     bufs.clear();
!     bufs.push_back(uscaleData);
!     bufs.push_back(usbuf);
!     bufs.push_back(ufbuf);
  }
  
  void FeatureEvaluator::getMats()
  {
!     if (!(sbufFlag & SBUF_VALID))
!     {
!         usbuf.copyTo(sbuf);
!         sbufFlag |= SBUF_VALID;
!     }
  }
  
  float FeatureEvaluator::calcOrd(int) const { return 0.; }
! int FeatureEvaluator::calcCat(int) const { return 0; }
  
  bool FeatureEvaluator::updateScaleData( Size imgsz, const std::vector<float>& _scales )
  {
!     if( scaleData.empty() )
!         scaleData = makePtr<std::vector<ScaleData> >();
  
!     size_t i, nscales = _scales.size();
!     bool recalcOptFeatures = nscales != scaleData->size();
!     scaleData->resize(nscales);
! 
!     int layer_dy = 0;
!     Point layer_ofs(0,0);
!     Size prevBufSize = sbufSize;
!     sbufSize.width = std::max(sbufSize.width, (int)alignSize(cvRound(imgsz.width/_scales[0]) + 31, 32));
!     recalcOptFeatures = recalcOptFeatures || sbufSize.width != prevBufSize.width;
! 
!     for( i = 0; i < nscales; i++ )
!     {
!         FeatureEvaluator::ScaleData& s = scaleData->at(i);
!         if( !recalcOptFeatures && fabs(s.scale - _scales[i]) > FLT_EPSILON*100*_scales[i] )
!             recalcOptFeatures = true;
!         float sc = _scales[i];
!         Size sz;
!         sz.width = cvRound(imgsz.width/sc);
!         sz.height = cvRound(imgsz.height/sc);
!         s.ystep = sc >= 2 ? 1 : 2;
!         s.scale = sc;
!         s.szi = Size(sz.width+1, sz.height+1);
! 
!         if( i == 0 )
!         {
!             layer_dy = s.szi.height;
!         }
! 
!         if( layer_ofs.x + s.szi.width > sbufSize.width )
!         {
!             layer_ofs = Point(0, layer_ofs.y + layer_dy);
!             layer_dy = s.szi.height;
!         }
!         s.layer_ofs = layer_ofs.y*sbufSize.width + layer_ofs.x;
!         layer_ofs.x += s.szi.width;
!     }
! 
!     layer_ofs.y += layer_dy;
!     sbufSize.height = std::max(sbufSize.height, layer_ofs.y);
!     recalcOptFeatures = recalcOptFeatures || sbufSize.height != prevBufSize.height;
!     return recalcOptFeatures;
  }
  
  
  bool FeatureEvaluator::setImage( InputArray _image, const std::vector<float>& _scales )
  {
!     Size imgsz = _image.size();
!     bool recalcOptFeatures = updateScaleData(imgsz, _scales);
  
!     size_t i, nscales = scaleData->size();
!     if (nscales == 0)
!     {
!         return false;
!     }
!     Size sz0 = scaleData->at(0).szi;
!     sz0 = Size(std::max(rbuf.cols, (int)alignSize(sz0.width, 16)), std::max(rbuf.rows, sz0.height));
! 
!     if (recalcOptFeatures)
!     {
!         computeOptFeatures();
!         copyVectorToUMat(*scaleData, uscaleData);
!     }
! 
!     if (_image.isUMat() && localSize.area() > 0)
!     {
!         usbuf.create(sbufSize.height*nchannels, sbufSize.width, CV_32S);
!         urbuf.create(sz0, CV_8U);
! 
!         for (i = 0; i < nscales; i++)
!         {
!             const ScaleData& s = scaleData->at(i);
!             UMat dst(urbuf, Rect(0, 0, s.szi.width - 1, s.szi.height - 1));
!             resize(_image, dst, dst.size(), 1. / s.scale, 1. / s.scale, INTER_LINEAR);
!             computeChannels((int)i, dst);
!         }
!         sbufFlag = USBUF_VALID;
!     }
!     else
!     {
!         Mat image = _image.getMat();
!         sbuf.create(sbufSize.height*nchannels, sbufSize.width, CV_32S);
!         rbuf.create(sz0, CV_8U);
! 
!         for (i = 0; i < nscales; i++)
!         {
!             const ScaleData& s = scaleData->at(i);
!             Mat dst(s.szi.height - 1, s.szi.width - 1, CV_8U, rbuf.ptr());
!             resize(image, dst, dst.size(), 1. / s.scale, 1. / s.scale, INTER_LINEAR);
!             computeChannels((int)i, dst);
!         }
!         sbufFlag = SBUF_VALID;
!     }
  
!     return true;
  }
  
  //----------------------------------------------  HaarEvaluator ---------------------------------------
  
  bool HaarEvaluator::Feature :: read( const FileNode& node )
  {
!     FileNode rnode = node[CC_RECTS];
!     FileNodeIterator it = rnode.begin(), it_end = rnode.end();
  
!     int ri;
!     for( ri = 0; ri < RECT_NUM; ri++ )
!     {
!         rect[ri].r = Rect();
!         rect[ri].weight = 0.f;
!     }
! 
!     for(ri = 0; it != it_end; ++it, ri++)
!     {
!         FileNodeIterator it2 = (*it).begin();
!         it2 >> rect[ri].r.x >> rect[ri].r.y >>
!             rect[ri].r.width >> rect[ri].r.height >> rect[ri].weight;
!     }
  
!     tilted = (int)node[CC_TILTED] != 0;
!     return true;
  }
  
  HaarEvaluator::HaarEvaluator()
  {
!     optfeaturesPtr = 0;
!     pwin = 0;
!     localSize = Size(4, 2);
!     lbufSize = Size(0, 0);
!     nchannels = 0;
!     tofs = 0;
  }
  
  HaarEvaluator::~HaarEvaluator()
--- 385,562 ----
  
  bool FeatureEvaluator::read(const FileNode&, Size _origWinSize)
  {
! origWinSize = _origWinSize;
! localSize = lbufSize = Size(cascadedetectcpp_INTEGER_388_1_0, cascadedetectcpp_INTEGER_388_2_0);
! if (scaleData.empty())
! scaleData = makePtr<std::vector<ScaleData> >();
! else
! scaleData->clear();
! return true;
  }
  
  Ptr<FeatureEvaluator> FeatureEvaluator::clone() const { return Ptr<FeatureEvaluator>(); }
! int FeatureEvaluator::getFeatureType() const {return -cascadedetectcpp_INTEGER_397_1_1;}
  bool FeatureEvaluator::setWindow(Point, int) { return true; }
  void FeatureEvaluator::getUMats(std::vector<UMat>& bufs)
  {
! if (!(sbufFlag & USBUF_VALID))
! {
! sbuf.copyTo(usbuf);
! sbufFlag |= USBUF_VALID;
! }
! 
! bufs.clear();
! bufs.push_back(uscaleData);
! bufs.push_back(usbuf);
! bufs.push_back(ufbuf);
  }
  
  void FeatureEvaluator::getMats()
  {
! if (!(sbufFlag & SBUF_VALID))
! {
! usbuf.copyTo(sbuf);
! sbufFlag |= SBUF_VALID;
! }
  }
  
  float FeatureEvaluator::calcOrd(int) const { return 0.; }
! int FeatureEvaluator::calcCat(int) const { return cascadedetectcpp_INTEGER_423_1_0; }
  
  bool FeatureEvaluator::updateScaleData( Size imgsz, const std::vector<float>& _scales )
  {
! if( scaleData.empty() )
! scaleData = makePtr<std::vector<ScaleData> >();
! 
! size_t i, nscales = _scales.size();
! bool recalcOptFeatures = nscales != scaleData->size();
! scaleData->resize(nscales);
! 
! int layer_dy = cascadedetectcpp_INTEGER_434_1_0;
! Point layer_ofs(cascadedetectcpp_INTEGER_435_1_0,cascadedetectcpp_INTEGER_435_2_0);
! Size prevBufSize = sbufSize;
! sbufSize.width = std::max(sbufSize.width, (int)alignSize(cvRound(imgsz.width/_scales[cascadedetectcpp_INTEGER_437_1_0]) + cascadedetectcpp_INTEGER_437_2_31, cascadedetectcpp_INTEGER_437_3_32));
! recalcOptFeatures = recalcOptFeatures || sbufSize.width != prevBufSize.width;
! 
! for( i = cascadedetectcpp_INTEGER_440_1_0; i < nscales; i+=cascadedetectcpp_INTEGER_440_2_1 )
! {
! FeatureEvaluator::ScaleData& s = scaleData->at(i);
! if( !recalcOptFeatures && fabs(s.scale - _scales[i]) > FLT_EPSILON*cascadedetectcpp_INTEGER_443_1_100*_scales[i] )
! recalcOptFeatures = true;
! float sc = _scales[i];
! Size sz;
! sz.width = cvRound(imgsz.width/sc);
! sz.height = cvRound(imgsz.height/sc);
! s.ystep = sc >= cascadedetectcpp_INTEGER_449_1_2 ? cascadedetectcpp_INTEGER_449_2_1 : cascadedetectcpp_INTEGER_449_3_2;
! s.scale = sc;
! s.szi = Size(sz.width+cascadedetectcpp_INTEGER_451_1_1, sz.height+cascadedetectcpp_INTEGER_451_2_1);
  
! if( i == cascadedetectcpp_INTEGER_453_1_0 )
! {
! layer_dy = s.szi.height;
! }
! 
! if( layer_ofs.x + s.szi.width > sbufSize.width )
! {
! layer_ofs = Point(cascadedetectcpp_INTEGER_460_1_0, layer_ofs.y + layer_dy);
! layer_dy = s.szi.height;
! }
! s.layer_ofs = layer_ofs.y*sbufSize.width + layer_ofs.x;
! layer_ofs.x += s.szi.width;
! }
! 
! layer_ofs.y += layer_dy;
! sbufSize.height = std::max(sbufSize.height, layer_ofs.y);
! recalcOptFeatures = recalcOptFeatures || sbufSize.height != prevBufSize.height;
! return recalcOptFeatures;
  }
  
  
  bool FeatureEvaluator::setImage( InputArray _image, const std::vector<float>& _scales )
  {
! Size imgsz = _image.size();
! bool recalcOptFeatures = updateScaleData(imgsz, _scales);
! 
! size_t i, nscales = scaleData->size();
! if (nscales == cascadedetectcpp_INTEGER_480_1_0)
! {
! return false;
! }
! Size sz0 = scaleData->at(cascadedetectcpp_INTEGER_484_1_0).szi;
! sz0 = Size(std::max(rbuf.cols, (int)alignSize(sz0.width, cascadedetectcpp_INTEGER_485_1_16)), std::max(rbuf.rows, sz0.height));
! 
! if (recalcOptFeatures)
! {
! computeOptFeatures();
! copyVectorToUMat(*scaleData, uscaleData);
! }
! 
! if (_image.isUMat() && localSize.area() > cascadedetectcpp_INTEGER_493_1_0)
! {
! usbuf.create(sbufSize.height*nchannels, sbufSize.width, CV_32S);
! urbuf.create(sz0, CV_8U);
  
! for (i = cascadedetectcpp_INTEGER_498_1_0; i < nscales; i+=cascadedetectcpp_INTEGER_498_2_1)
! {
! const ScaleData& s = scaleData->at(i);
! UMat dst(urbuf, Rect(cascadedetectcpp_INTEGER_501_1_0, cascadedetectcpp_INTEGER_501_2_0, s.szi.width - cascadedetectcpp_INTEGER_501_3_1, s.szi.height - cascadedetectcpp_INTEGER_501_4_1));
! resize(_image, dst, dst.size(), 1. / s.scale, 1. / s.scale, INTER_LINEAR);
! computeChannels((int)i, dst);
! }
! sbufFlag = USBUF_VALID;
! }
! else
! {
! Mat image = _image.getMat();
! sbuf.create(sbufSize.height*nchannels, sbufSize.width, CV_32S);
! rbuf.create(sz0, CV_8U);
! 
! for (i = cascadedetectcpp_INTEGER_513_1_0; i < nscales; i+=cascadedetectcpp_INTEGER_513_2_1)
! {
! const ScaleData& s = scaleData->at(i);
! Mat dst(s.szi.height - cascadedetectcpp_INTEGER_516_1_1, s.szi.width - cascadedetectcpp_INTEGER_516_2_1, CV_8U, rbuf.ptr());
! resize(image, dst, dst.size(), 1. / s.scale, 1. / s.scale, INTER_LINEAR);
! computeChannels((int)i, dst);
! }
! sbufFlag = SBUF_VALID;
! }
  
! return true;
  }
  
  //----------------------------------------------  HaarEvaluator ---------------------------------------
  
  bool HaarEvaluator::Feature :: read( const FileNode& node )
  {
! FileNode rnode = node[CC_RECTS];
! FileNodeIterator it = rnode.begin(), it_end = rnode.end();
  
! int ri;
! for( ri = cascadedetectcpp_INTEGER_534_1_0; ri < RECT_NUM; ri+=cascadedetectcpp_INTEGER_534_2_1 )
! {
! rect[ri].r = Rect();
! rect[ri].weight = 0.f;
! }
  
! for(ri = cascadedetectcpp_INTEGER_540_1_0; it != it_end; ++it, ri+=cascadedetectcpp_INTEGER_540_2_1)
! {
! FileNodeIterator it2 = (*it).begin();
! it2 >> rect[ri].r.x >> rect[ri].r.y >>
! rect[ri].r.width >> rect[ri].r.height >> rect[ri].weight;
! }
! 
! tilted = (int)node[CC_TILTED] != cascadedetectcpp_INTEGER_547_1_0;
! return true;
  }
  
  HaarEvaluator::HaarEvaluator()
  {
! optfeaturesPtr = cascadedetectcpp_INTEGER_553_1_0;
! pwin = cascadedetectcpp_INTEGER_554_1_0;
! localSize = Size(cascadedetectcpp_INTEGER_555_1_4, cascadedetectcpp_INTEGER_555_2_2);
! lbufSize = Size(cascadedetectcpp_INTEGER_556_1_0, cascadedetectcpp_INTEGER_556_2_0);
! nchannels = cascadedetectcpp_INTEGER_557_1_0;
! tofs = cascadedetectcpp_INTEGER_558_1_0;
  }
  
  HaarEvaluator::~HaarEvaluator()
***************
*** 564,758 ****
  
  bool HaarEvaluator::read(const FileNode& node, Size _origWinSize)
  {
!     if (!FeatureEvaluator::read(node, _origWinSize))
!         return false;
!     size_t i, n = node.size();
!     CV_Assert(n > 0);
!     if(features.empty())
!         features = makePtr<std::vector<Feature> >();
!     if(optfeatures.empty())
!         optfeatures = makePtr<std::vector<OptFeature> >();
!     if (optfeatures_lbuf.empty())
!         optfeatures_lbuf = makePtr<std::vector<OptFeature> >();
!     features->resize(n);
!     FileNodeIterator it = node.begin();
!     hasTiltedFeatures = false;
!     std::vector<Feature>& ff = *features;
!     sbufSize = Size();
!     ufbuf.release();
! 
!     for(i = 0; i < n; i++, ++it)
!     {
!         if(!ff[i].read(*it))
!             return false;
!         if( ff[i].tilted )
!             hasTiltedFeatures = true;
!     }
!     nchannels = hasTiltedFeatures ? 3 : 2;
!     normrect = Rect(1, 1, origWinSize.width - 2, origWinSize.height - 2);
! 
!     localSize = lbufSize = Size(0, 0);
!     if (ocl::haveOpenCL())
!     {
!         if (ocl::Device::getDefault().isAMD() || ocl::Device::getDefault().isIntel())
!         {
!             localSize = Size(8, 8);
!             lbufSize = Size(origWinSize.width + localSize.width,
!                             origWinSize.height + localSize.height);
!             if (lbufSize.area() > 1024)
!                 lbufSize = Size(0, 0);
!         }
!     }
  
!     return true;
  }
  
  Ptr<FeatureEvaluator> HaarEvaluator::clone() const
  {
!     Ptr<HaarEvaluator> ret = makePtr<HaarEvaluator>();
!     *ret = *this;
!     return ret;
  }
  
  
  void HaarEvaluator::computeChannels(int scaleIdx, InputArray img)
  {
!     const ScaleData& s = scaleData->at(scaleIdx);
!     sqofs = hasTiltedFeatures ? sbufSize.area() * 2 : sbufSize.area();
  
!     if (img.isUMat())
!     {
!         int sx = s.layer_ofs % sbufSize.width;
!         int sy = s.layer_ofs / sbufSize.width;
!         int sqy = sy + (sqofs / sbufSize.width);
!         UMat sum(usbuf, Rect(sx, sy, s.szi.width, s.szi.height));
!         UMat sqsum(usbuf, Rect(sx, sqy, s.szi.width, s.szi.height));
!         sqsum.flags = (sqsum.flags & ~UMat::DEPTH_MASK) | CV_32S;
! 
!         if (hasTiltedFeatures)
!         {
!             int sty = sy + (tofs / sbufSize.width);
!             UMat tilted(usbuf, Rect(sx, sty, s.szi.width, s.szi.height));
!             integral(img, sum, sqsum, tilted, CV_32S, CV_32S);
!         }
!         else
!         {
!             UMatData* u = sqsum.u;
!             integral(img, sum, sqsum, noArray(), CV_32S, CV_32S);
!             CV_Assert(sqsum.u == u && sqsum.size() == s.szi && sqsum.type()==CV_32S);
!         }
!     }
!     else
!     {
!         Mat sum(s.szi, CV_32S, sbuf.ptr<int>() + s.layer_ofs, sbuf.step);
!         Mat sqsum(s.szi, CV_32S, sum.ptr<int>() + sqofs, sbuf.step);
! 
!         if (hasTiltedFeatures)
!         {
!             Mat tilted(s.szi, CV_32S, sum.ptr<int>() + tofs, sbuf.step);
!             integral(img, sum, sqsum, tilted, CV_32S, CV_32S);
!         }
!         else
!             integral(img, sum, sqsum, noArray(), CV_32S, CV_32S);
!     }
  }
  
  void HaarEvaluator::computeOptFeatures()
  {
!     if (hasTiltedFeatures)
!         tofs = sbufSize.area();
  
!     int sstep = sbufSize.width;
!     CV_SUM_OFS( nofs[0], nofs[1], nofs[2], nofs[3], 0, normrect, sstep );
  
!     size_t fi, nfeatures = features->size();
!     const std::vector<Feature>& ff = *features;
!     optfeatures->resize(nfeatures);
!     optfeaturesPtr = &(*optfeatures)[0];
!     for( fi = 0; fi < nfeatures; fi++ )
!         optfeaturesPtr[fi].setOffsets( ff[fi], sstep, tofs );
!     optfeatures_lbuf->resize(nfeatures);
  
!     for( fi = 0; fi < nfeatures; fi++ )
!         optfeatures_lbuf->at(fi).setOffsets(ff[fi], lbufSize.width > 0 ? lbufSize.width : sstep, tofs);
  
!     copyVectorToUMat(*optfeatures_lbuf, ufbuf);
  }
  
  bool HaarEvaluator::setWindow( Point pt, int scaleIdx )
  {
!     const ScaleData& s = getScaleData(scaleIdx);
  
!     if( pt.x < 0 || pt.y < 0 ||
!         pt.x + origWinSize.width >= s.szi.width ||
!         pt.y + origWinSize.height >= s.szi.height )
!         return false;
! 
!     pwin = &sbuf.at<int>(pt) + s.layer_ofs;
!     const int* pq = (const int*)(pwin + sqofs);
!     int valsum = CALC_SUM_OFS(nofs, pwin);
!     unsigned valsqsum = (unsigned)(CALC_SUM_OFS(nofs, pq));
! 
!     double area = normrect.area();
!     double nf = area * valsqsum - (double)valsum * valsum;
!     if( nf > 0. )
!     {
!         nf = std::sqrt(nf);
!         varianceNormFactor = (float)(1./nf);
!         return area*varianceNormFactor < 1e-1;
!     }
!     else
!     {
!         varianceNormFactor = 1.f;
!         return false;
!     }
  }
  
  
  void HaarEvaluator::OptFeature::setOffsets( const Feature& _f, int step, int _tofs )
  {
!     weight[0] = _f.rect[0].weight;
!     weight[1] = _f.rect[1].weight;
!     weight[2] = _f.rect[2].weight;
! 
!     if( _f.tilted )
!     {
!         CV_TILTED_OFS( ofs[0][0], ofs[0][1], ofs[0][2], ofs[0][3], _tofs, _f.rect[0].r, step );
!         CV_TILTED_OFS( ofs[1][0], ofs[1][1], ofs[1][2], ofs[1][3], _tofs, _f.rect[1].r, step );
!         CV_TILTED_OFS( ofs[2][0], ofs[2][1], ofs[2][2], ofs[2][3], _tofs, _f.rect[2].r, step );
!     }
!     else
!     {
!         CV_SUM_OFS( ofs[0][0], ofs[0][1], ofs[0][2], ofs[0][3], 0, _f.rect[0].r, step );
!         CV_SUM_OFS( ofs[1][0], ofs[1][1], ofs[1][2], ofs[1][3], 0, _f.rect[1].r, step );
!         CV_SUM_OFS( ofs[2][0], ofs[2][1], ofs[2][2], ofs[2][3], 0, _f.rect[2].r, step );
!     }
  }
  
  Rect HaarEvaluator::getNormRect() const
  {
!     return normrect;
  }
  
  int HaarEvaluator::getSquaresOffset() const
  {
!     return sqofs;
  }
  
  //----------------------------------------------  LBPEvaluator -------------------------------------
  bool LBPEvaluator::Feature :: read(const FileNode& node )
  {
!     FileNode rnode = node[CC_RECT];
!     FileNodeIterator it = rnode.begin();
!     it >> rect.x >> rect.y >> rect.width >> rect.height;
!     return true;
  }
  
  LBPEvaluator::LBPEvaluator()
  {
!     features = makePtr<std::vector<Feature> >();
!     optfeatures = makePtr<std::vector<OptFeature> >();
!     scaleData = makePtr<std::vector<ScaleData> >();
  }
  
  LBPEvaluator::~LBPEvaluator()
--- 565,759 ----
  
  bool HaarEvaluator::read(const FileNode& node, Size _origWinSize)
  {
! if (!FeatureEvaluator::read(node, _origWinSize))
! return false;
! size_t i, n = node.size();
! CV_Assert(n > cascadedetectcpp_INTEGER_570_1_0);
! if(features.empty())
! features = makePtr<std::vector<Feature> >();
! if(optfeatures.empty())
! optfeatures = makePtr<std::vector<OptFeature> >();
! if (optfeatures_lbuf.empty())
! optfeatures_lbuf = makePtr<std::vector<OptFeature> >();
! features->resize(n);
! FileNodeIterator it = node.begin();
! hasTiltedFeatures = false;
! std::vector<Feature>& ff = *features;
! sbufSize = Size();
! ufbuf.release();
! 
! for(i = cascadedetectcpp_INTEGER_584_1_0; i < n; i+=cascadedetectcpp_INTEGER_584_2_1, ++it)
! {
! if(!ff[i].read(*it))
! return false;
! if( ff[i].tilted )
! hasTiltedFeatures = true;
! }
! nchannels = hasTiltedFeatures ? cascadedetectcpp_INTEGER_591_1_3 : cascadedetectcpp_INTEGER_591_2_2;
! normrect = Rect(cascadedetectcpp_INTEGER_592_1_1, cascadedetectcpp_INTEGER_592_2_1, origWinSize.width - cascadedetectcpp_INTEGER_592_3_2, origWinSize.height - cascadedetectcpp_INTEGER_592_4_2);
! 
! localSize = lbufSize = Size(cascadedetectcpp_INTEGER_594_1_0, cascadedetectcpp_INTEGER_594_2_0);
! if (ocl::haveOpenCL())
! {
! if (ocl::Device::getDefault().isAMD() || ocl::Device::getDefault().isIntel())
! {
! localSize = Size(cascadedetectcpp_INTEGER_599_1_8, cascadedetectcpp_INTEGER_599_2_8);
! lbufSize = Size(origWinSize.width + localSize.width,
! origWinSize.height + localSize.height);
! if (lbufSize.area() > cascadedetectcpp_INTEGER_602_1_1024)
! lbufSize = Size(cascadedetectcpp_INTEGER_603_1_0, cascadedetectcpp_INTEGER_603_2_0);
! }
! }
  
! return true;
  }
  
  Ptr<FeatureEvaluator> HaarEvaluator::clone() const
  {
! Ptr<HaarEvaluator> ret = makePtr<HaarEvaluator>();
! *ret = *this;
! return ret;
  }
  
  
  void HaarEvaluator::computeChannels(int scaleIdx, InputArray img)
  {
! const ScaleData& s = scaleData->at(scaleIdx);
! sqofs = hasTiltedFeatures ? sbufSize.area() * cascadedetectcpp_INTEGER_621_1_2 : sbufSize.area();
  
! if (img.isUMat())
! {
! int sx = s.layer_ofs % sbufSize.width;
! int sy = s.layer_ofs / sbufSize.width;
! int sqy = sy + (sqofs / sbufSize.width);
! UMat sum(usbuf, Rect(sx, sy, s.szi.width, s.szi.height));
! UMat sqsum(usbuf, Rect(sx, sqy, s.szi.width, s.szi.height));
! sqsum.flags = (sqsum.flags & ~UMat::DEPTH_MASK) | CV_32S;
! 
! if (hasTiltedFeatures)
! {
! int sty = sy + (tofs / sbufSize.width);
! UMat tilted(usbuf, Rect(sx, sty, s.szi.width, s.szi.height));
! integral(img, sum, sqsum, tilted, CV_32S, CV_32S);
! }
! else
! {
! UMatData* u = sqsum.u;
! integral(img, sum, sqsum, noArray(), CV_32S, CV_32S);
! CV_Assert(sqsum.u == u && sqsum.size() == s.szi && sqsum.type()==CV_32S);
! }
! }
! else
! {
! Mat sum(s.szi, CV_32S, sbuf.ptr<int>() + s.layer_ofs, sbuf.step);
! Mat sqsum(s.szi, CV_32S, sum.ptr<int>() + sqofs, sbuf.step);
! 
! if (hasTiltedFeatures)
! {
! Mat tilted(s.szi, CV_32S, sum.ptr<int>() + tofs, sbuf.step);
! integral(img, sum, sqsum, tilted, CV_32S, CV_32S);
! }
! else
! integral(img, sum, sqsum, noArray(), CV_32S, CV_32S);
! }
  }
  
  void HaarEvaluator::computeOptFeatures()
  {
! if (hasTiltedFeatures)
! tofs = sbufSize.area();
  
! int sstep = sbufSize.width;
! CV_SUM_OFS( nofs[cascadedetectcpp_INTEGER_666_1_0], nofs[cascadedetectcpp_INTEGER_666_2_1], nofs[cascadedetectcpp_INTEGER_666_3_2], nofs[cascadedetectcpp_INTEGER_666_4_3], cascadedetectcpp_INTEGER_666_5_0, normrect, sstep );
  
! size_t fi, nfeatures = features->size();
! const std::vector<Feature>& ff = *features;
! optfeatures->resize(nfeatures);
! optfeaturesPtr = &(*optfeatures)[cascadedetectcpp_INTEGER_671_1_0];
! for( fi = cascadedetectcpp_INTEGER_672_1_0; fi < nfeatures; fi+=cascadedetectcpp_INTEGER_672_2_1 )
! optfeaturesPtr[fi].setOffsets( ff[fi], sstep, tofs );
! optfeatures_lbuf->resize(nfeatures);
  
! for( fi = cascadedetectcpp_INTEGER_676_1_0; fi < nfeatures; fi+=cascadedetectcpp_INTEGER_676_2_1 )
! optfeatures_lbuf->at(fi).setOffsets(ff[fi], lbufSize.width > cascadedetectcpp_INTEGER_677_1_0 ? lbufSize.width : sstep, tofs);
  
! copyVectorToUMat(*optfeatures_lbuf, ufbuf);
  }
  
  bool HaarEvaluator::setWindow( Point pt, int scaleIdx )
  {
! const ScaleData& s = getScaleData(scaleIdx);
  
! if( pt.x < cascadedetectcpp_INTEGER_686_1_0 || pt.y < cascadedetectcpp_INTEGER_686_2_0 ||
! pt.x + origWinSize.width >= s.szi.width ||
! pt.y + origWinSize.height >= s.szi.height )
! return false;
! 
! pwin = &sbuf.at<int>(pt) + s.layer_ofs;
! const int* pq = (const int*)(pwin + sqofs);
! int valsum = CALC_SUM_OFS(nofs, pwin);
! unsigned valsqsum = (unsigned)(CALC_SUM_OFS(nofs, pq));
! 
! double area = normrect.area();
! double nf = area * valsqsum - (double)valsum * valsum;
! if( nf > 0. )
! {
! nf = std::sqrt(nf);
! varianceNormFactor = (float)(1./nf);
! return area*varianceNormFactor < 1e-1;
! }
! else
! {
! varianceNormFactor = 1.f;
! return false;
! }
  }
  
  
  void HaarEvaluator::OptFeature::setOffsets( const Feature& _f, int step, int _tofs )
  {
! weight[cascadedetectcpp_INTEGER_714_1_0] = _f.rect[cascadedetectcpp_INTEGER_714_2_0].weight;
! weight[cascadedetectcpp_INTEGER_715_1_1] = _f.rect[cascadedetectcpp_INTEGER_715_2_1].weight;
! weight[cascadedetectcpp_INTEGER_716_1_2] = _f.rect[cascadedetectcpp_INTEGER_716_2_2].weight;
! 
! if( _f.tilted )
! {
! CV_TILTED_OFS( ofs[cascadedetectcpp_INTEGER_720_1_0][cascadedetectcpp_INTEGER_720_2_0], ofs[cascadedetectcpp_INTEGER_720_3_0][cascadedetectcpp_INTEGER_720_4_1], ofs[cascadedetectcpp_INTEGER_720_5_0][cascadedetectcpp_INTEGER_720_6_2], ofs[cascadedetectcpp_INTEGER_720_7_0][cascadedetectcpp_INTEGER_720_8_3], _tofs, _f.rect[cascadedetectcpp_INTEGER_720_9_0].r, step );
! CV_TILTED_OFS( ofs[cascadedetectcpp_INTEGER_721_1_1][cascadedetectcpp_INTEGER_721_2_0], ofs[cascadedetectcpp_INTEGER_721_3_1][cascadedetectcpp_INTEGER_721_4_1], ofs[cascadedetectcpp_INTEGER_721_5_1][cascadedetectcpp_INTEGER_721_6_2], ofs[cascadedetectcpp_INTEGER_721_7_1][cascadedetectcpp_INTEGER_721_8_3], _tofs, _f.rect[cascadedetectcpp_INTEGER_721_9_1].r, step );
! CV_TILTED_OFS( ofs[cascadedetectcpp_INTEGER_722_1_2][cascadedetectcpp_INTEGER_722_2_0], ofs[cascadedetectcpp_INTEGER_722_3_2][cascadedetectcpp_INTEGER_722_4_1], ofs[cascadedetectcpp_INTEGER_722_5_2][cascadedetectcpp_INTEGER_722_6_2], ofs[cascadedetectcpp_INTEGER_722_7_2][cascadedetectcpp_INTEGER_722_8_3], _tofs, _f.rect[cascadedetectcpp_INTEGER_722_9_2].r, step );
! }
! else
! {
! CV_SUM_OFS( ofs[cascadedetectcpp_INTEGER_726_1_0][cascadedetectcpp_INTEGER_726_2_0], ofs[cascadedetectcpp_INTEGER_726_3_0][cascadedetectcpp_INTEGER_726_4_1], ofs[cascadedetectcpp_INTEGER_726_5_0][cascadedetectcpp_INTEGER_726_6_2], ofs[cascadedetectcpp_INTEGER_726_7_0][cascadedetectcpp_INTEGER_726_8_3], cascadedetectcpp_INTEGER_726_9_0, _f.rect[cascadedetectcpp_INTEGER_726_10_0].r, step );
! CV_SUM_OFS( ofs[cascadedetectcpp_INTEGER_727_1_1][cascadedetectcpp_INTEGER_727_2_0], ofs[cascadedetectcpp_INTEGER_727_3_1][cascadedetectcpp_INTEGER_727_4_1], ofs[cascadedetectcpp_INTEGER_727_5_1][cascadedetectcpp_INTEGER_727_6_2], ofs[cascadedetectcpp_INTEGER_727_7_1][cascadedetectcpp_INTEGER_727_8_3], cascadedetectcpp_INTEGER_727_9_0, _f.rect[cascadedetectcpp_INTEGER_727_10_1].r, step );
! CV_SUM_OFS( ofs[cascadedetectcpp_INTEGER_728_1_2][cascadedetectcpp_INTEGER_728_2_0], ofs[cascadedetectcpp_INTEGER_728_3_2][cascadedetectcpp_INTEGER_728_4_1], ofs[cascadedetectcpp_INTEGER_728_5_2][cascadedetectcpp_INTEGER_728_6_2], ofs[cascadedetectcpp_INTEGER_728_7_2][cascadedetectcpp_INTEGER_728_8_3], cascadedetectcpp_INTEGER_728_9_0, _f.rect[cascadedetectcpp_INTEGER_728_10_2].r, step );
! }
  }
  
  Rect HaarEvaluator::getNormRect() const
  {
! return normrect;
  }
  
  int HaarEvaluator::getSquaresOffset() const
  {
! return sqofs;
  }
  
  //----------------------------------------------  LBPEvaluator -------------------------------------
  bool LBPEvaluator::Feature :: read(const FileNode& node )
  {
! FileNode rnode = node[CC_RECT];
! FileNodeIterator it = rnode.begin();
! it >> rect.x >> rect.y >> rect.width >> rect.height;
! return true;
  }
  
  LBPEvaluator::LBPEvaluator()
  {
! features = makePtr<std::vector<Feature> >();
! optfeatures = makePtr<std::vector<OptFeature> >();
! scaleData = makePtr<std::vector<ScaleData> >();
  }
  
  LBPEvaluator::~LBPEvaluator()
***************
*** 761,867 ****
  
  bool LBPEvaluator::read( const FileNode& node, Size _origWinSize )
  {
!     if (!FeatureEvaluator::read(node, _origWinSize))
!         return false;
!     if(features.empty())
!         features = makePtr<std::vector<Feature> >();
!     if(optfeatures.empty())
!         optfeatures = makePtr<std::vector<OptFeature> >();
!     if (optfeatures_lbuf.empty())
!         optfeatures_lbuf = makePtr<std::vector<OptFeature> >();
! 
!     features->resize(node.size());
!     optfeaturesPtr = 0;
!     FileNodeIterator it = node.begin(), it_end = node.end();
!     std::vector<Feature>& ff = *features;
!     for(int i = 0; it != it_end; ++it, i++)
!     {
!         if(!ff[i].read(*it))
!             return false;
!     }
!     nchannels = 1;
!     localSize = lbufSize = Size(0, 0);
!     if (ocl::haveOpenCL())
!         localSize = Size(8, 8);
  
!     return true;
  }
  
  Ptr<FeatureEvaluator> LBPEvaluator::clone() const
  {
!     Ptr<LBPEvaluator> ret = makePtr<LBPEvaluator>();
!     *ret = *this;
!     return ret;
  }
  
  void LBPEvaluator::computeChannels(int scaleIdx, InputArray _img)
  {
!     const ScaleData& s = scaleData->at(scaleIdx);
  
!     if (_img.isUMat())
!     {
!         int sx = s.layer_ofs % sbufSize.width;
!         int sy = s.layer_ofs / sbufSize.width;
!         UMat sum(usbuf, Rect(sx, sy, s.szi.width, s.szi.height));
!         integral(_img, sum, noArray(), noArray(), CV_32S);
!     }
!     else
!     {
!         Mat sum(s.szi, CV_32S, sbuf.ptr<int>() + s.layer_ofs, sbuf.step);
!         integral(_img, sum, noArray(), noArray(), CV_32S);
!     }
  }
  
  void LBPEvaluator::computeOptFeatures()
  {
!     int sstep = sbufSize.width;
  
!     size_t fi, nfeatures = features->size();
!     const std::vector<Feature>& ff = *features;
!     optfeatures->resize(nfeatures);
!     optfeaturesPtr = &(*optfeatures)[0];
!     for( fi = 0; fi < nfeatures; fi++ )
!         optfeaturesPtr[fi].setOffsets( ff[fi], sstep );
!     copyVectorToUMat(*optfeatures, ufbuf);
  }
  
  
  void LBPEvaluator::OptFeature::setOffsets( const Feature& _f, int step )
  {
!     Rect tr = _f.rect;
!     int w0 = tr.width;
!     int h0 = tr.height;
! 
!     CV_SUM_OFS( ofs[0], ofs[1], ofs[4], ofs[5], 0, tr, step );
!     tr.x += 2*w0;
!     CV_SUM_OFS( ofs[2], ofs[3], ofs[6], ofs[7], 0, tr, step );
!     tr.y += 2*h0;
!     CV_SUM_OFS( ofs[10], ofs[11], ofs[14], ofs[15], 0, tr, step );
!     tr.x -= 2*w0;
!     CV_SUM_OFS( ofs[8], ofs[9], ofs[12], ofs[13], 0, tr, step );
  }
  
  
  bool LBPEvaluator::setWindow( Point pt, int scaleIdx )
  {
!     CV_Assert(0 <= scaleIdx && scaleIdx < (int)scaleData->size());
!     const ScaleData& s = scaleData->at(scaleIdx);
  
!     if( pt.x < 0 || pt.y < 0 ||
!         pt.x + origWinSize.width >= s.szi.width ||
!         pt.y + origWinSize.height >= s.szi.height )
!         return false;
  
!     pwin = &sbuf.at<int>(pt) + s.layer_ofs;
!     return true;
  }
  
  
  Ptr<FeatureEvaluator> FeatureEvaluator::create( int featureType )
  {
!     return featureType == HAAR ? Ptr<FeatureEvaluator>(new HaarEvaluator) :
!         featureType == LBP ? Ptr<FeatureEvaluator>(new LBPEvaluator) :
!         Ptr<FeatureEvaluator>();
  }
  
  //---------------------------------------- Classifier Cascade --------------------------------------------
--- 762,868 ----
  
  bool LBPEvaluator::read( const FileNode& node, Size _origWinSize )
  {
! if (!FeatureEvaluator::read(node, _origWinSize))
! return false;
! if(features.empty())
! features = makePtr<std::vector<Feature> >();
! if(optfeatures.empty())
! optfeatures = makePtr<std::vector<OptFeature> >();
! if (optfeatures_lbuf.empty())
! optfeatures_lbuf = makePtr<std::vector<OptFeature> >();
! 
! features->resize(node.size());
! optfeaturesPtr = cascadedetectcpp_INTEGER_774_1_0;
! FileNodeIterator it = node.begin(), it_end = node.end();
! std::vector<Feature>& ff = *features;
! for(int i = cascadedetectcpp_INTEGER_777_1_0; it != it_end; ++it, i+=cascadedetectcpp_INTEGER_777_2_1)
! {
! if(!ff[i].read(*it))
! return false;
! }
! nchannels = cascadedetectcpp_INTEGER_782_1_1;
! localSize = lbufSize = Size(cascadedetectcpp_INTEGER_783_1_0, cascadedetectcpp_INTEGER_783_2_0);
! if (ocl::haveOpenCL())
! localSize = Size(cascadedetectcpp_INTEGER_785_1_8, cascadedetectcpp_INTEGER_785_2_8);
  
! return true;
  }
  
  Ptr<FeatureEvaluator> LBPEvaluator::clone() const
  {
! Ptr<LBPEvaluator> ret = makePtr<LBPEvaluator>();
! *ret = *this;
! return ret;
  }
  
  void LBPEvaluator::computeChannels(int scaleIdx, InputArray _img)
  {
! const ScaleData& s = scaleData->at(scaleIdx);
  
! if (_img.isUMat())
! {
! int sx = s.layer_ofs % sbufSize.width;
! int sy = s.layer_ofs / sbufSize.width;
! UMat sum(usbuf, Rect(sx, sy, s.szi.width, s.szi.height));
! integral(_img, sum, noArray(), noArray(), CV_32S);
! }
! else
! {
! Mat sum(s.szi, CV_32S, sbuf.ptr<int>() + s.layer_ofs, sbuf.step);
! integral(_img, sum, noArray(), noArray(), CV_32S);
! }
  }
  
  void LBPEvaluator::computeOptFeatures()
  {
! int sstep = sbufSize.width;
  
! size_t fi, nfeatures = features->size();
! const std::vector<Feature>& ff = *features;
! optfeatures->resize(nfeatures);
! optfeaturesPtr = &(*optfeatures)[cascadedetectcpp_INTEGER_822_1_0];
! for( fi = cascadedetectcpp_INTEGER_823_1_0; fi < nfeatures; fi+=cascadedetectcpp_INTEGER_823_2_1 )
! optfeaturesPtr[fi].setOffsets( ff[fi], sstep );
! copyVectorToUMat(*optfeatures, ufbuf);
  }
  
  
  void LBPEvaluator::OptFeature::setOffsets( const Feature& _f, int step )
  {
! Rect tr = _f.rect;
! int w0 = tr.width;
! int h0 = tr.height;
! 
! CV_SUM_OFS( ofs[cascadedetectcpp_INTEGER_835_1_0], ofs[cascadedetectcpp_INTEGER_835_2_1], ofs[cascadedetectcpp_INTEGER_835_3_4], ofs[cascadedetectcpp_INTEGER_835_4_5], cascadedetectcpp_INTEGER_835_5_0, tr, step );
! tr.x += cascadedetectcpp_INTEGER_836_1_2*w0;
! CV_SUM_OFS( ofs[cascadedetectcpp_INTEGER_837_1_2], ofs[cascadedetectcpp_INTEGER_837_2_3], ofs[cascadedetectcpp_INTEGER_837_3_6], ofs[cascadedetectcpp_INTEGER_837_4_7], cascadedetectcpp_INTEGER_837_5_0, tr, step );
! tr.y += cascadedetectcpp_INTEGER_838_1_2*h0;
! CV_SUM_OFS( ofs[cascadedetectcpp_INTEGER_839_1_10], ofs[cascadedetectcpp_INTEGER_839_2_11], ofs[cascadedetectcpp_INTEGER_839_3_14], ofs[cascadedetectcpp_INTEGER_839_4_15], cascadedetectcpp_INTEGER_839_5_0, tr, step );
! tr.x -= cascadedetectcpp_INTEGER_840_1_2*w0;
! CV_SUM_OFS( ofs[cascadedetectcpp_INTEGER_841_1_8], ofs[cascadedetectcpp_INTEGER_841_2_9], ofs[cascadedetectcpp_INTEGER_841_3_12], ofs[cascadedetectcpp_INTEGER_841_4_13], cascadedetectcpp_INTEGER_841_5_0, tr, step );
  }
  
  
  bool LBPEvaluator::setWindow( Point pt, int scaleIdx )
  {
! CV_Assert(cascadedetectcpp_INTEGER_847_1_0 <= scaleIdx && scaleIdx < (int)scaleData->size());
! const ScaleData& s = scaleData->at(scaleIdx);
  
! if( pt.x < cascadedetectcpp_INTEGER_850_1_0 || pt.y < cascadedetectcpp_INTEGER_850_2_0 ||
! pt.x + origWinSize.width >= s.szi.width ||
! pt.y + origWinSize.height >= s.szi.height )
! return false;
  
! pwin = &sbuf.at<int>(pt) + s.layer_ofs;
! return true;
  }
  
  
  Ptr<FeatureEvaluator> FeatureEvaluator::create( int featureType )
  {
! return featureType == HAAR ? Ptr<FeatureEvaluator>(new HaarEvaluator) :
! featureType == LBP ? Ptr<FeatureEvaluator>(new LBPEvaluator) :
! Ptr<FeatureEvaluator>();
  }
  
  //---------------------------------------- Classifier Cascade --------------------------------------------
***************
*** 876,1039 ****
  
  bool CascadeClassifierImpl::empty() const
  {
!     return !oldCascade && data.stages.empty();
  }
  
  bool CascadeClassifierImpl::load(const String& filename)
  {
!     oldCascade.release();
!     data = Data();
!     featureEvaluator.release();
  
!     FileStorage fs(filename, FileStorage::READ);
!     if( !fs.isOpened() )
!         return false;
  
!     if( read_(fs.getFirstTopLevelNode()) )
!         return true;
  
!     fs.release();
  
!     oldCascade.reset((CvHaarClassifierCascade*)cvLoad(filename.c_str(), 0, 0, 0));
!     return !oldCascade.empty();
  }
  
  void CascadeClassifierImpl::read(const FileNode& node)
  {
!     read_(node);
  }
  
  int CascadeClassifierImpl::runAt( Ptr<FeatureEvaluator>& evaluator, Point pt, int scaleIdx, double& weight )
  {
!     assert( !oldCascade &&
!            (data.featureType == FeatureEvaluator::HAAR ||
!             data.featureType == FeatureEvaluator::LBP ||
!             data.featureType == FeatureEvaluator::HOG) );
! 
!     if( !evaluator->setWindow(pt, scaleIdx) )
!         return -1;
!     if( data.maxNodesPerTree == 1 )
!     {
!         if( data.featureType == FeatureEvaluator::HAAR )
!             return predictOrderedStump<HaarEvaluator>( *this, evaluator, weight );
!         else if( data.featureType == FeatureEvaluator::LBP )
!             return predictCategoricalStump<LBPEvaluator>( *this, evaluator, weight );
!         else
!             return -2;
!     }
!     else
!     {
!         if( data.featureType == FeatureEvaluator::HAAR )
!             return predictOrdered<HaarEvaluator>( *this, evaluator, weight );
!         else if( data.featureType == FeatureEvaluator::LBP )
!             return predictCategorical<LBPEvaluator>( *this, evaluator, weight );
!         else
!             return -2;
!     }
  }
  
  void CascadeClassifierImpl::setMaskGenerator(const Ptr<MaskGenerator>& _maskGenerator)
  {
!     maskGenerator=_maskGenerator;
  }
  Ptr<CascadeClassifierImpl::MaskGenerator> CascadeClassifierImpl::getMaskGenerator()
  {
!     return maskGenerator;
  }
  
  Ptr<BaseCascadeClassifier::MaskGenerator> createFaceDetectionMaskGenerator()
  {
  #ifdef HAVE_TEGRA_OPTIMIZATION
!     if (tegra::useTegra())
!         return tegra::getCascadeClassifierMaskGenerator();
  #endif
!     return Ptr<BaseCascadeClassifier::MaskGenerator>();
  }
  
  class CascadeClassifierInvoker : public ParallelLoopBody
  {
  public:
!     CascadeClassifierInvoker( CascadeClassifierImpl& _cc, int _nscales, int _nstripes,
!                               const FeatureEvaluator::ScaleData* _scaleData,
!                               const int* _stripeSizes, std::vector<Rect>& _vec,
!                               std::vector<int>& _levels, std::vector<double>& _weights,
!                               bool outputLevels, const Mat& _mask, Mutex* _mtx)
!     {
!         classifier = &_cc;
!         nscales = _nscales;
!         nstripes = _nstripes;
!         scaleData = _scaleData;
!         stripeSizes = _stripeSizes;
!         rectangles = &_vec;
!         rejectLevels = outputLevels ? &_levels : 0;
!         levelWeights = outputLevels ? &_weights : 0;
!         mask = _mask;
!         mtx = _mtx;
!     }
! 
!     void operator()(const Range& range) const
!     {
!         Ptr<FeatureEvaluator> evaluator = classifier->featureEvaluator->clone();
!         double gypWeight = 0.;
!         Size origWinSize = classifier->data.origWinSize;
! 
!         for( int scaleIdx = 0; scaleIdx < nscales; scaleIdx++ )
!         {
!             const FeatureEvaluator::ScaleData& s = scaleData[scaleIdx];
!             float scalingFactor = s.scale;
!             int yStep = s.ystep;
!             int stripeSize = stripeSizes[scaleIdx];
!             int y0 = range.start*stripeSize;
!             Size szw = s.getWorkingSize(origWinSize);
!             int y1 = std::min(range.end*stripeSize, szw.height);
!             Size winSize(cvRound(origWinSize.width * scalingFactor),
!                          cvRound(origWinSize.height * scalingFactor));
! 
!             for( int y = y0; y < y1; y += yStep )
!             {
!                 for( int x = 0; x < szw.width; x += yStep )
!                 {
!                     int result = classifier->runAt(evaluator, Point(x, y), scaleIdx, gypWeight);
!                     if( rejectLevels )
!                     {
!                         if( result == 1 )
!                             result = -(int)classifier->data.stages.size();
!                         if( classifier->data.stages.size() + result == 0 )
!                         {
!                             mtx->lock();
!                             rectangles->push_back(Rect(cvRound(x*scalingFactor),
!                                                        cvRound(y*scalingFactor),
!                                                        winSize.width, winSize.height));
!                             rejectLevels->push_back(-result);
!                             levelWeights->push_back(gypWeight);
!                             mtx->unlock();
!                         }
!                     }
!                     else if( result > 0 )
!                     {
!                         mtx->lock();
!                         rectangles->push_back(Rect(cvRound(x*scalingFactor),
!                                                    cvRound(y*scalingFactor),
!                                                    winSize.width, winSize.height));
!                         mtx->unlock();
!                     }
!                     if( result == 0 )
!                         x += yStep;
!                 }
!             }
!         }
!     }
! 
!     CascadeClassifierImpl* classifier;
!     std::vector<Rect>* rectangles;
!     int nscales, nstripes;
!     const FeatureEvaluator::ScaleData* scaleData;
!     const int* stripeSizes;
!     std::vector<int> *rejectLevels;
!     std::vector<double> *levelWeights;
!     std::vector<float> scales;
!     Mat mask;
!     Mutex* mtx;
  };
  
  
--- 877,1040 ----
  
  bool CascadeClassifierImpl::empty() const
  {
! return !oldCascade && data.stages.empty();
  }
  
  bool CascadeClassifierImpl::load(const String& filename)
  {
! oldCascade.release();
! data = Data();
! featureEvaluator.release();
  
! FileStorage fs(filename, FileStorage::READ);
! if( !fs.isOpened() )
! return false;
  
! if( read_(fs.getFirstTopLevelNode()) )
! return true;
  
! fs.release();
  
! oldCascade.reset((CvHaarClassifierCascade*)cvLoad(filename.c_str(), cascadedetectcpp_INTEGER_897_1_0, cascadedetectcpp_INTEGER_897_2_0, cascadedetectcpp_INTEGER_897_3_0));
! return !oldCascade.empty();
  }
  
  void CascadeClassifierImpl::read(const FileNode& node)
  {
! read_(node);
  }
  
  int CascadeClassifierImpl::runAt( Ptr<FeatureEvaluator>& evaluator, Point pt, int scaleIdx, double& weight )
  {
! assert( !oldCascade &&
! (data.featureType == FeatureEvaluator::HAAR ||
! data.featureType == FeatureEvaluator::LBP ||
! data.featureType == FeatureEvaluator::HOG) );
! 
! if( !evaluator->setWindow(pt, scaleIdx) )
! return -cascadedetectcpp_INTEGER_914_1_1;
! if( data.maxNodesPerTree == cascadedetectcpp_INTEGER_915_1_1 )
! {
! if( data.featureType == FeatureEvaluator::HAAR )
! return predictOrderedStump<HaarEvaluator>( *this, evaluator, weight );
! else if( data.featureType == FeatureEvaluator::LBP )
! return predictCategoricalStump<LBPEvaluator>( *this, evaluator, weight );
! else
! return -cascadedetectcpp_INTEGER_922_1_2;
! }
! else
! {
! if( data.featureType == FeatureEvaluator::HAAR )
! return predictOrdered<HaarEvaluator>( *this, evaluator, weight );
! else if( data.featureType == FeatureEvaluator::LBP )
! return predictCategorical<LBPEvaluator>( *this, evaluator, weight );
! else
! return -cascadedetectcpp_INTEGER_931_1_2;
! }
  }
  
  void CascadeClassifierImpl::setMaskGenerator(const Ptr<MaskGenerator>& _maskGenerator)
  {
! maskGenerator=_maskGenerator;
  }
  Ptr<CascadeClassifierImpl::MaskGenerator> CascadeClassifierImpl::getMaskGenerator()
  {
! return maskGenerator;
  }
  
  Ptr<BaseCascadeClassifier::MaskGenerator> createFaceDetectionMaskGenerator()
  {
  #ifdef HAVE_TEGRA_OPTIMIZATION
! if (tegra::useTegra())
! return tegra::getCascadeClassifierMaskGenerator();
  #endif
! return Ptr<BaseCascadeClassifier::MaskGenerator>();
  }
  
  class CascadeClassifierInvoker : public ParallelLoopBody
  {
  public:
! CascadeClassifierInvoker( CascadeClassifierImpl& _cc, int _nscales, int _nstripes,
! const FeatureEvaluator::ScaleData* _scaleData,
! const int* _stripeSizes, std::vector<Rect>& _vec,
! std::vector<int>& _levels, std::vector<double>& _weights,
! bool outputLevels, const Mat& _mask, Mutex* _mtx)
! {
! classifier = &_cc;
! nscales = _nscales;
! nstripes = _nstripes;
! scaleData = _scaleData;
! stripeSizes = _stripeSizes;
! rectangles = &_vec;
! rejectLevels = outputLevels ? &_levels : cascadedetectcpp_INTEGER_968_1_0;
! levelWeights = outputLevels ? &_weights : cascadedetectcpp_INTEGER_969_1_0;
! mask = _mask;
! mtx = _mtx;
! }
! 
! void operator()(const Range& range) const
! {
! Ptr<FeatureEvaluator> evaluator = classifier->featureEvaluator->clone();
! double gypWeight = 0.;
! Size origWinSize = classifier->data.origWinSize;
! 
! for( int scaleIdx = cascadedetectcpp_INTEGER_980_1_0; scaleIdx < nscales; scaleIdx+=cascadedetectcpp_INTEGER_980_2_1 )
! {
! const FeatureEvaluator::ScaleData& s = scaleData[scaleIdx];
! float scalingFactor = s.scale;
! int yStep = s.ystep;
! int stripeSize = stripeSizes[scaleIdx];
! int y0 = range.start*stripeSize;
! Size szw = s.getWorkingSize(origWinSize);
! int y1 = std::min(range.end*stripeSize, szw.height);
! Size winSize(cvRound(origWinSize.width * scalingFactor),
! cvRound(origWinSize.height * scalingFactor));
! 
! for( int y = y0; y < y1; y += yStep )
! {
! for( int x = cascadedetectcpp_INTEGER_994_1_0; x < szw.width; x += yStep )
! {
! int result = classifier->runAt(evaluator, Point(x, y), scaleIdx, gypWeight);
! if( rejectLevels )
! {
! if( result == cascadedetectcpp_INTEGER_999_1_1 )
! result = -(int)classifier->data.stages.size();
! if( classifier->data.stages.size() + result == cascadedetectcpp_INTEGER_1001_1_0 )
! {
! mtx->lock();
! rectangles->push_back(Rect(cvRound(x*scalingFactor),
! cvRound(y*scalingFactor),
! winSize.width, winSize.height));
! rejectLevels->push_back(-result);
! levelWeights->push_back(gypWeight);
! mtx->unlock();
! }
! }
! else if( result > cascadedetectcpp_INTEGER_1012_1_0 )
! {
! mtx->lock();
! rectangles->push_back(Rect(cvRound(x*scalingFactor),
! cvRound(y*scalingFactor),
! winSize.width, winSize.height));
! mtx->unlock();
! }
! if( result == cascadedetectcpp_INTEGER_1020_1_0 )
! x += yStep;
! }
! }
! }
! }
! 
! CascadeClassifierImpl* classifier;
! std::vector<Rect>* rectangles;
! int nscales, nstripes;
! const FeatureEvaluator::ScaleData* scaleData;
! const int* stripeSizes;
! std::vector<int> *rejectLevels;
! std::vector<double> *levelWeights;
! std::vector<float> scales;
! Mat mask;
! Mutex* mtx;
  };
  
  
***************
*** 1042,1553 ****
  
  #ifdef HAVE_OPENCL
  bool CascadeClassifierImpl::ocl_detectMultiScaleNoGrouping( const std::vector<float>& scales,
!                                                             std::vector<Rect>& candidates )
  {
!     int featureType = getFeatureType();
!     std::vector<UMat> bufs;
!     featureEvaluator->getUMats(bufs);
!     Size localsz = featureEvaluator->getLocalSize();
!     if( localsz.area() == 0 )
!         return false;
!     Size lbufSize = featureEvaluator->getLocalBufSize();
!     size_t localsize[] = { (size_t)localsz.width, (size_t)localsz.height };
!     const int grp_per_CU = 12;
!     size_t globalsize[] = { grp_per_CU*ocl::Device::getDefault().maxComputeUnits()*localsize[0], localsize[1] };
!     bool ok = false;
! 
!     ufacepos.create(1, MAX_FACES*3+1, CV_32S);
!     UMat ufacepos_count(ufacepos, Rect(0, 0, 1, 1));
!     ufacepos_count.setTo(Scalar::all(0));
! 
!     if( ustages.empty() )
!     {
!         copyVectorToUMat(data.stages, ustages);
!         if (!data.stumps.empty())
!             copyVectorToUMat(data.stumps, unodes);
!         else
!             copyVectorToUMat(data.nodes, unodes);
!         copyVectorToUMat(data.leaves, uleaves);
!         if( !data.subsets.empty() )
!             copyVectorToUMat(data.subsets, usubsets);
!     }
! 
!     int nstages = (int)data.stages.size();
!     int splitstage_ocl = 1;
! 
!     if( featureType == FeatureEvaluator::HAAR )
!     {
!         Ptr<HaarEvaluator> haar = featureEvaluator.dynamicCast<HaarEvaluator>();
!         if( haar.empty() )
!             return false;
! 
!         if( haarKernel.empty() )
!         {
!             String opts;
!             if (lbufSize.area())
!                 opts = format("-D LOCAL_SIZE_X=%d -D LOCAL_SIZE_Y=%d -D SUM_BUF_SIZE=%d -D SUM_BUF_STEP=%d -D NODE_COUNT=%d -D SPLIT_STAGE=%d -D N_STAGES=%d -D MAX_FACES=%d -D HAAR",
!                               localsz.width, localsz.height, lbufSize.area(), lbufSize.width, data.maxNodesPerTree, splitstage_ocl, nstages, MAX_FACES);
!             else
!                 opts = format("-D LOCAL_SIZE_X=%d -D LOCAL_SIZE_Y=%d -D NODE_COUNT=%d -D SPLIT_STAGE=%d -D N_STAGES=%d -D MAX_FACES=%d -D HAAR",
!                               localsz.width, localsz.height, data.maxNodesPerTree, splitstage_ocl, nstages, MAX_FACES);
!             haarKernel.create("runHaarClassifier", ocl::objdetect::cascadedetect_oclsrc, opts);
!             if( haarKernel.empty() )
!                 return false;
!         }
! 
!         Rect normrect = haar->getNormRect();
!         int sqofs = haar->getSquaresOffset();
! 
!         haarKernel.args((int)scales.size(),
!                         ocl::KernelArg::PtrReadOnly(bufs[0]), // scaleData
!                         ocl::KernelArg::ReadOnlyNoSize(bufs[1]), // sum
!                         ocl::KernelArg::PtrReadOnly(bufs[2]), // optfeatures
! 
!                         // cascade classifier
!                         ocl::KernelArg::PtrReadOnly(ustages),
!                         ocl::KernelArg::PtrReadOnly(unodes),
!                         ocl::KernelArg::PtrReadOnly(uleaves),
! 
!                         ocl::KernelArg::PtrWriteOnly(ufacepos), // positions
!                         normrect, sqofs, data.origWinSize);
!         ok = haarKernel.run(2, globalsize, localsize, true);
!     }
!     else if( featureType == FeatureEvaluator::LBP )
!     {
!         if (data.maxNodesPerTree > 1)
!             return false;
! 
!         Ptr<LBPEvaluator> lbp = featureEvaluator.dynamicCast<LBPEvaluator>();
!         if( lbp.empty() )
!             return false;
! 
!         if( lbpKernel.empty() )
!         {
!             String opts;
!             if (lbufSize.area())
!                 opts = format("-D LOCAL_SIZE_X=%d -D LOCAL_SIZE_Y=%d -D SUM_BUF_SIZE=%d -D SUM_BUF_STEP=%d -D SPLIT_STAGE=%d -D N_STAGES=%d -D MAX_FACES=%d -D LBP",
!                               localsz.width, localsz.height, lbufSize.area(), lbufSize.width, splitstage_ocl, nstages, MAX_FACES);
!             else
!                 opts = format("-D LOCAL_SIZE_X=%d -D LOCAL_SIZE_Y=%d -D SPLIT_STAGE=%d -D N_STAGES=%d -D MAX_FACES=%d -D LBP",
!                               localsz.width, localsz.height, splitstage_ocl, nstages, MAX_FACES);
!             lbpKernel.create("runLBPClassifierStumpSimple", ocl::objdetect::cascadedetect_oclsrc, opts);
!             if( lbpKernel.empty() )
!                 return false;
!         }
! 
!         int subsetSize = (data.ncategories + 31)/32;
!         lbpKernel.args((int)scales.size(),
!                        ocl::KernelArg::PtrReadOnly(bufs[0]), // scaleData
!                        ocl::KernelArg::ReadOnlyNoSize(bufs[1]), // sum
!                        ocl::KernelArg::PtrReadOnly(bufs[2]), // optfeatures
! 
!                        // cascade classifier
!                        ocl::KernelArg::PtrReadOnly(ustages),
!                        ocl::KernelArg::PtrReadOnly(unodes),
!                        ocl::KernelArg::PtrReadOnly(usubsets),
!                        subsetSize,
! 
!                        ocl::KernelArg::PtrWriteOnly(ufacepos), // positions
!                        data.origWinSize);
! 
!         ok = lbpKernel.run(2, globalsize, localsize, true);
!     }
! 
!     if( ok )
!     {
!         Mat facepos = ufacepos.getMat(ACCESS_READ);
!         const int* fptr = facepos.ptr<int>();
!         int nfaces = fptr[0];
!         nfaces = std::min(nfaces, (int)MAX_FACES);
! 
!         for( int i = 0; i < nfaces; i++ )
!         {
!             const FeatureEvaluator::ScaleData& s = featureEvaluator->getScaleData(fptr[i*3 + 1]);
!             candidates.push_back(Rect(cvRound(fptr[i*3 + 2]*s.scale),
!                                       cvRound(fptr[i*3 + 3]*s.scale),
!                                       cvRound(data.origWinSize.width*s.scale),
!                                       cvRound(data.origWinSize.height*s.scale)));
!         }
!     }
!     return ok;
  }
  #endif
  
  bool CascadeClassifierImpl::isOldFormatCascade() const
  {
!     return !oldCascade.empty();
  }
  
  int CascadeClassifierImpl::getFeatureType() const
  {
!     return featureEvaluator->getFeatureType();
  }
  
  Size CascadeClassifierImpl::getOriginalWindowSize() const
  {
!     return data.origWinSize;
  }
  
  void* CascadeClassifierImpl::getOldCascade()
  {
!     return oldCascade;
  }
  
  static void detectMultiScaleOldFormat( const Mat& image, Ptr<CvHaarClassifierCascade> oldCascade,
!                                        std::vector<Rect>& objects,
!                                        std::vector<int>& rejectLevels,
!                                        std::vector<double>& levelWeights,
!                                        std::vector<CvAvgComp>& vecAvgComp,
!                                        double scaleFactor, int minNeighbors,
!                                        int flags, Size minObjectSize, Size maxObjectSize,
!                                        bool outputRejectLevels = false )
! {
!     MemStorage storage(cvCreateMemStorage(0));
!     CvMat _image = image;
!     CvSeq* _objects = cvHaarDetectObjectsForROC( &_image, oldCascade, storage, rejectLevels, levelWeights, scaleFactor,
!                                                  minNeighbors, flags, minObjectSize, maxObjectSize, outputRejectLevels );
!     Seq<CvAvgComp>(_objects).copyTo(vecAvgComp);
!     objects.resize(vecAvgComp.size());
!     std::transform(vecAvgComp.begin(), vecAvgComp.end(), objects.begin(), getRect());
  }
  
  
  void CascadeClassifierImpl::detectMultiScaleNoGrouping( InputArray _image, std::vector<Rect>& candidates,
!                                                     std::vector<int>& rejectLevels, std::vector<double>& levelWeights,
!                                                     double scaleFactor, Size minObjectSize, Size maxObjectSize,
!                                                     bool outputRejectLevels )
  {
!     Size imgsz = _image.size();
  
!     Mat grayImage;
!     _InputArray gray;
  
!     candidates.clear();
!     rejectLevels.clear();
!     levelWeights.clear();
  
!     if( maxObjectSize.height == 0 || maxObjectSize.width == 0 )
!         maxObjectSize = imgsz;
  
  #ifdef HAVE_OPENCL
!     bool use_ocl = tryOpenCL && ocl::useOpenCL() &&
!          featureEvaluator->getLocalSize().area() > 0 &&
!          ocl::Device::getDefault().type() != ocl::Device::TYPE_CPU &&
!          (data.minNodesPerTree == data.maxNodesPerTree) &&
!          !isOldFormatCascade() &&
!          maskGenerator.empty() &&
!          !outputRejectLevels;
  #endif
  
!     /*if( use_ocl )
!     {
!         if (_image.channels() > 1)
!             cvtColor(_image, ugrayImage, COLOR_BGR2GRAY);
!         else if (_image.isUMat())
!             ugrayImage = _image.getUMat();
!         else
!             _image.copyTo(ugrayImage);
!         gray = ugrayImage;
!     }
!     else*/
!     {
!         if (_image.channels() > 1)
!             cvtColor(_image, grayImage, COLOR_BGR2GRAY);
!         else if (_image.isMat())
!             grayImage = _image.getMat();
!         else
!             _image.copyTo(grayImage);
!         gray = grayImage;
!     }
! 
!     std::vector<float> scales;
!     scales.reserve(1024);
! 
!     for( double factor = 1; ; factor *= scaleFactor )
!     {
!         Size originalWindowSize = getOriginalWindowSize();
! 
!         Size windowSize( cvRound(originalWindowSize.width*factor), cvRound(originalWindowSize.height*factor) );
!         if( windowSize.width > maxObjectSize.width || windowSize.height > maxObjectSize.height ||
!             windowSize.width > imgsz.width || windowSize.height > imgsz.height )
!             break;
!         if( windowSize.width < minObjectSize.width || windowSize.height < minObjectSize.height )
!             continue;
!         scales.push_back((float)factor);
!     }
  
!     if( scales.size() == 0 || !featureEvaluator->setImage(gray, scales) )
!         return;
  
  #ifdef HAVE_OPENCL
!     // OpenCL code
!     CV_OCL_RUN(use_ocl, ocl_detectMultiScaleNoGrouping( scales, candidates ))
  
!     tryOpenCL = false;
  #endif
  
!     // CPU code
!     featureEvaluator->getMats();
!     {
!         Mat currentMask;
!         if (maskGenerator)
!             currentMask = maskGenerator->generateMask(gray.getMat());
! 
!         size_t i, nscales = scales.size();
!         cv::AutoBuffer<int> stripeSizeBuf(nscales);
!         int* stripeSizes = stripeSizeBuf;
!         const FeatureEvaluator::ScaleData* s = &featureEvaluator->getScaleData(0);
!         Size szw = s->getWorkingSize(data.origWinSize);
!         int nstripes = cvCeil(szw.width/32.);
!         for( i = 0; i < nscales; i++ )
!         {
!             szw = s[i].getWorkingSize(data.origWinSize);
!             stripeSizes[i] = std::max((szw.height/s[i].ystep + nstripes-1)/nstripes, 1)*s[i].ystep;
!         }
! 
!         CascadeClassifierInvoker invoker(*this, (int)nscales, nstripes, s, stripeSizes,
!                                          candidates, rejectLevels, levelWeights,
!                                          outputRejectLevels, currentMask, &mtx);
!         parallel_for_(Range(0, nstripes), invoker);
!     }
  }
  
  
  void CascadeClassifierImpl::detectMultiScale( InputArray _image, std::vector<Rect>& objects,
!                                           std::vector<int>& rejectLevels,
!                                           std::vector<double>& levelWeights,
!                                           double scaleFactor, int minNeighbors,
!                                           int flags, Size minObjectSize, Size maxObjectSize,
!                                           bool outputRejectLevels )
! {
!     CV_Assert( scaleFactor > 1 && _image.depth() == CV_8U );
! 
!     if( empty() )
!         return;
! 
!     if( isOldFormatCascade() )
!     {
!         Mat image = _image.getMat();
!         std::vector<CvAvgComp> fakeVecAvgComp;
!         detectMultiScaleOldFormat( image, oldCascade, objects, rejectLevels, levelWeights, fakeVecAvgComp, scaleFactor,
!                                    minNeighbors, flags, minObjectSize, maxObjectSize, outputRejectLevels );
!     }
!     else
!     {
!         detectMultiScaleNoGrouping( _image, objects, rejectLevels, levelWeights, scaleFactor, minObjectSize, maxObjectSize,
!                                     outputRejectLevels );
!         const double GROUP_EPS = 0.2;
!         if( outputRejectLevels )
!         {
!             groupRectangles( objects, rejectLevels, levelWeights, minNeighbors, GROUP_EPS );
!         }
!         else
!         {
!             groupRectangles( objects, minNeighbors, GROUP_EPS );
!         }
!     }
  }
  
  void CascadeClassifierImpl::detectMultiScale( InputArray _image, std::vector<Rect>& objects,
!                                           double scaleFactor, int minNeighbors,
!                                           int flags, Size minObjectSize, Size maxObjectSize)
  {
!     std::vector<int> fakeLevels;
!     std::vector<double> fakeWeights;
!     detectMultiScale( _image, objects, fakeLevels, fakeWeights, scaleFactor,
!         minNeighbors, flags, minObjectSize, maxObjectSize );
  }
  
  void CascadeClassifierImpl::detectMultiScale( InputArray _image, std::vector<Rect>& objects,
!                                           std::vector<int>& numDetections, double scaleFactor,
!                                           int minNeighbors, int flags, Size minObjectSize,
!                                           Size maxObjectSize )
! {
!     Mat image = _image.getMat();
!     CV_Assert( scaleFactor > 1 && image.depth() == CV_8U );
! 
!     if( empty() )
!         return;
! 
!     std::vector<int> fakeLevels;
!     std::vector<double> fakeWeights;
!     if( isOldFormatCascade() )
!     {
!         std::vector<CvAvgComp> vecAvgComp;
!         detectMultiScaleOldFormat( image, oldCascade, objects, fakeLevels, fakeWeights, vecAvgComp, scaleFactor,
!                                    minNeighbors, flags, minObjectSize, maxObjectSize );
!         numDetections.resize(vecAvgComp.size());
!         std::transform(vecAvgComp.begin(), vecAvgComp.end(), numDetections.begin(), getNeighbors());
!     }
!     else
!     {
!         detectMultiScaleNoGrouping( image, objects, fakeLevels, fakeWeights, scaleFactor, minObjectSize, maxObjectSize );
!         const double GROUP_EPS = 0.2;
!         groupRectangles( objects, numDetections, minNeighbors, GROUP_EPS );
!     }
  }
  
  
  CascadeClassifierImpl::Data::Data()
  {
!     stageType = featureType = ncategories = maxNodesPerTree = 0;
  }
  
  bool CascadeClassifierImpl::Data::read(const FileNode &root)
  {
!     static const float THRESHOLD_EPS = 1e-5f;
  
!     // load stage params
!     String stageTypeStr = (String)root[CC_STAGE_TYPE];
!     if( stageTypeStr == CC_BOOST )
!         stageType = BOOST;
!     else
!         return false;
! 
!     String featureTypeStr = (String)root[CC_FEATURE_TYPE];
!     if( featureTypeStr == CC_HAAR )
!         featureType = FeatureEvaluator::HAAR;
!     else if( featureTypeStr == CC_LBP )
!         featureType = FeatureEvaluator::LBP;
!     else if( featureTypeStr == CC_HOG )
!     {
!         featureType = FeatureEvaluator::HOG;
!         CV_Error(Error::StsNotImplemented, "HOG cascade is not supported in 3.0");
!     }
!     else
!         return false;
! 
!     origWinSize.width = (int)root[CC_WIDTH];
!     origWinSize.height = (int)root[CC_HEIGHT];
!     CV_Assert( origWinSize.height > 0 && origWinSize.width > 0 );
! 
!     // load feature params
!     FileNode fn = root[CC_FEATURE_PARAMS];
!     if( fn.empty() )
!         return false;
! 
!     ncategories = fn[CC_MAX_CAT_COUNT];
!     int subsetSize = (ncategories + 31)/32,
!         nodeStep = 3 + ( ncategories>0 ? subsetSize : 1 );
! 
!     // load stages
!     fn = root[CC_STAGES];
!     if( fn.empty() )
!         return false;
! 
!     stages.reserve(fn.size());
!     classifiers.clear();
!     nodes.clear();
!     stumps.clear();
! 
!     FileNodeIterator it = fn.begin(), it_end = fn.end();
!     minNodesPerTree = INT_MAX;
!     maxNodesPerTree = 0;
! 
!     for( int si = 0; it != it_end; si++, ++it )
!     {
!         FileNode fns = *it;
!         Stage stage;
!         stage.threshold = (float)fns[CC_STAGE_THRESHOLD] - THRESHOLD_EPS;
!         fns = fns[CC_WEAK_CLASSIFIERS];
!         if(fns.empty())
!             return false;
!         stage.ntrees = (int)fns.size();
!         stage.first = (int)classifiers.size();
!         stages.push_back(stage);
!         classifiers.reserve(stages[si].first + stages[si].ntrees);
! 
!         FileNodeIterator it1 = fns.begin(), it1_end = fns.end();
!         for( ; it1 != it1_end; ++it1 ) // weak trees
!         {
!             FileNode fnw = *it1;
!             FileNode internalNodes = fnw[CC_INTERNAL_NODES];
!             FileNode leafValues = fnw[CC_LEAF_VALUES];
!             if( internalNodes.empty() || leafValues.empty() )
!                 return false;
! 
!             DTree tree;
!             tree.nodeCount = (int)internalNodes.size()/nodeStep;
!             minNodesPerTree = std::min(minNodesPerTree, tree.nodeCount);
!             maxNodesPerTree = std::max(maxNodesPerTree, tree.nodeCount);
! 
!             classifiers.push_back(tree);
! 
!             nodes.reserve(nodes.size() + tree.nodeCount);
!             leaves.reserve(leaves.size() + leafValues.size());
!             if( subsetSize > 0 )
!                 subsets.reserve(subsets.size() + tree.nodeCount*subsetSize);
! 
!             FileNodeIterator internalNodesIter = internalNodes.begin(), internalNodesEnd = internalNodes.end();
! 
!             for( ; internalNodesIter != internalNodesEnd; ) // nodes
!             {
!                 DTreeNode node;
!                 node.left = (int)*internalNodesIter; ++internalNodesIter;
!                 node.right = (int)*internalNodesIter; ++internalNodesIter;
!                 node.featureIdx = (int)*internalNodesIter; ++internalNodesIter;
!                 if( subsetSize > 0 )
!                 {
!                     for( int j = 0; j < subsetSize; j++, ++internalNodesIter )
!                         subsets.push_back((int)*internalNodesIter);
!                     node.threshold = 0.f;
!                 }
!                 else
!                 {
!                     node.threshold = (float)*internalNodesIter; ++internalNodesIter;
!                 }
!                 nodes.push_back(node);
!             }
! 
!             internalNodesIter = leafValues.begin(), internalNodesEnd = leafValues.end();
! 
!             for( ; internalNodesIter != internalNodesEnd; ++internalNodesIter ) // leaves
!                 leaves.push_back((float)*internalNodesIter);
!         }
!     }
! 
!     if( maxNodesPerTree == 1 )
!     {
!         int nodeOfs = 0, leafOfs = 0;
!         size_t nstages = stages.size();
!         for( size_t stageIdx = 0; stageIdx < nstages; stageIdx++ )
!         {
!             const Stage& stage = stages[stageIdx];
! 
!             int ntrees = stage.ntrees;
!             for( int i = 0; i < ntrees; i++, nodeOfs++, leafOfs+= 2 )
!             {
!                 const DTreeNode& node = nodes[nodeOfs];
!                 stumps.push_back(Stump(node.featureIdx, node.threshold,
!                                        leaves[leafOfs], leaves[leafOfs+1]));
!             }
!         }
!     }
  
!     return true;
  }
  
  
  bool CascadeClassifierImpl::read_(const FileNode& root)
  {
  #ifdef HAVE_OPENCL
!     tryOpenCL = true;
!     haarKernel = ocl::Kernel();
!     lbpKernel = ocl::Kernel();
  #endif
!     ustages.release();
!     unodes.release();
!     uleaves.release();
!     if( !data.read(root) )
!         return false;
! 
!     // load features
!     featureEvaluator = FeatureEvaluator::create(data.featureType);
!     FileNode fn = root[CC_FEATURES];
!     if( fn.empty() )
!         return false;
  
!     return featureEvaluator->read(fn, data.origWinSize);
  }
  
  template<> void DefaultDeleter<CvHaarClassifierCascade>::operator ()(CvHaarClassifierCascade* obj) const
--- 1043,1554 ----
  
  #ifdef HAVE_OPENCL
  bool CascadeClassifierImpl::ocl_detectMultiScaleNoGrouping( const std::vector<float>& scales,
! std::vector<Rect>& candidates )
  {
! int featureType = getFeatureType();
! std::vector<UMat> bufs;
! featureEvaluator->getUMats(bufs);
! Size localsz = featureEvaluator->getLocalSize();
! if( localsz.area() == cascadedetectcpp_INTEGER_1051_1_0 )
! return false;
! Size lbufSize = featureEvaluator->getLocalBufSize();
! size_t localsize[] = { (size_t)localsz.width, (size_t)localsz.height };
! const int grp_per_CU = cascadedetectcpp_INTEGER_1055_1_12;
! size_t globalsize[] = { grp_per_CU*ocl::Device::getDefault().maxComputeUnits()*localsize[cascadedetectcpp_INTEGER_1056_1_0], localsize[cascadedetectcpp_INTEGER_1056_2_1] };
! bool ok = false;
! 
! ufacepos.create(cascadedetectcpp_INTEGER_1059_1_1, MAX_FACES*cascadedetectcpp_INTEGER_1059_2_3+cascadedetectcpp_INTEGER_1059_3_1, CV_32S);
! UMat ufacepos_count(ufacepos, Rect(cascadedetectcpp_INTEGER_1060_1_0, cascadedetectcpp_INTEGER_1060_2_0, cascadedetectcpp_INTEGER_1060_3_1, cascadedetectcpp_INTEGER_1060_4_1));
! ufacepos_count.setTo(Scalar::all(cascadedetectcpp_INTEGER_1061_1_0));
! 
! if( ustages.empty() )
! {
! copyVectorToUMat(data.stages, ustages);
! if (!data.stumps.empty())
! copyVectorToUMat(data.stumps, unodes);
! else
! copyVectorToUMat(data.nodes, unodes);
! copyVectorToUMat(data.leaves, uleaves);
! if( !data.subsets.empty() )
! copyVectorToUMat(data.subsets, usubsets);
! }
! 
! int nstages = (int)data.stages.size();
! int splitstage_ocl = cascadedetectcpp_INTEGER_1076_1_1;
! 
! if( featureType == FeatureEvaluator::HAAR )
! {
! Ptr<HaarEvaluator> haar = featureEvaluator.dynamicCast<HaarEvaluator>();
! if( haar.empty() )
! return false;
! 
! if( haarKernel.empty() )
! {
! String opts;
! if (lbufSize.area())
! opts = format("-D LOCAL_SIZE_X=%d -D LOCAL_SIZE_Y=%d -D SUM_BUF_SIZE=%d -D SUM_BUF_STEP=%d -D NODE_COUNT=%d -D SPLIT_STAGE=%d -D N_STAGES=%d -D MAX_FACES=%d -D HAAR",
! localsz.width, localsz.height, lbufSize.area(), lbufSize.width, data.maxNodesPerTree, splitstage_ocl, nstages, MAX_FACES);
! else
! opts = format("-D LOCAL_SIZE_X=%d -D LOCAL_SIZE_Y=%d -D NODE_COUNT=%d -D SPLIT_STAGE=%d -D N_STAGES=%d -D MAX_FACES=%d -D HAAR",
! localsz.width, localsz.height, data.maxNodesPerTree, splitstage_ocl, nstages, MAX_FACES);
! haarKernel.create("runHaarClassifier", ocl::objdetect::cascadedetect_oclsrc, opts);
! if( haarKernel.empty() )
! return false;
! }
! 
! Rect normrect = haar->getNormRect();
! int sqofs = haar->getSquaresOffset();
! 
! haarKernel.args((int)scales.size(),
! ocl::KernelArg::PtrReadOnly(bufs[cascadedetectcpp_INTEGER_1102_1_0]), // scaleData
! ocl::KernelArg::ReadOnlyNoSize(bufs[cascadedetectcpp_INTEGER_1103_1_1]), // sum
! ocl::KernelArg::PtrReadOnly(bufs[cascadedetectcpp_INTEGER_1104_1_2]), // optfeatures
! 
! // cascade classifier
! ocl::KernelArg::PtrReadOnly(ustages),
! ocl::KernelArg::PtrReadOnly(unodes),
! ocl::KernelArg::PtrReadOnly(uleaves),
! 
! ocl::KernelArg::PtrWriteOnly(ufacepos), // positions
! normrect, sqofs, data.origWinSize);
! ok = haarKernel.run(cascadedetectcpp_INTEGER_1113_1_2, globalsize, localsize, true);
! }
! else if( featureType == FeatureEvaluator::LBP )
! {
! if (data.maxNodesPerTree > cascadedetectcpp_INTEGER_1117_1_1)
! return false;
! 
! Ptr<LBPEvaluator> lbp = featureEvaluator.dynamicCast<LBPEvaluator>();
! if( lbp.empty() )
! return false;
! 
! if( lbpKernel.empty() )
! {
! String opts;
! if (lbufSize.area())
! opts = format("-D LOCAL_SIZE_X=%d -D LOCAL_SIZE_Y=%d -D SUM_BUF_SIZE=%d -D SUM_BUF_STEP=%d -D SPLIT_STAGE=%d -D N_STAGES=%d -D MAX_FACES=%d -D LBP",
! localsz.width, localsz.height, lbufSize.area(), lbufSize.width, splitstage_ocl, nstages, MAX_FACES);
! else
! opts = format("-D LOCAL_SIZE_X=%d -D LOCAL_SIZE_Y=%d -D SPLIT_STAGE=%d -D N_STAGES=%d -D MAX_FACES=%d -D LBP",
! localsz.width, localsz.height, splitstage_ocl, nstages, MAX_FACES);
! lbpKernel.create("runLBPClassifierStumpSimple", ocl::objdetect::cascadedetect_oclsrc, opts);
! if( lbpKernel.empty() )
! return false;
! }
! 
! int subsetSize = (data.ncategories + cascadedetectcpp_INTEGER_1138_1_31)/cascadedetectcpp_INTEGER_1138_2_32;
! lbpKernel.args((int)scales.size(),
! ocl::KernelArg::PtrReadOnly(bufs[cascadedetectcpp_INTEGER_1140_1_0]), // scaleData
! ocl::KernelArg::ReadOnlyNoSize(bufs[cascadedetectcpp_INTEGER_1141_1_1]), // sum
! ocl::KernelArg::PtrReadOnly(bufs[cascadedetectcpp_INTEGER_1142_1_2]), // optfeatures
! 
! // cascade classifier
! ocl::KernelArg::PtrReadOnly(ustages),
! ocl::KernelArg::PtrReadOnly(unodes),
! ocl::KernelArg::PtrReadOnly(usubsets),
! subsetSize,
! 
! ocl::KernelArg::PtrWriteOnly(ufacepos), // positions
! data.origWinSize);
! 
! ok = lbpKernel.run(cascadedetectcpp_INTEGER_1153_1_2, globalsize, localsize, true);
! }
! 
! if( ok )
! {
! Mat facepos = ufacepos.getMat(ACCESS_READ);
! const int* fptr = facepos.ptr<int>();
! int nfaces = fptr[cascadedetectcpp_INTEGER_1160_1_0];
! nfaces = std::min(nfaces, (int)MAX_FACES);
! 
! for( int i = cascadedetectcpp_INTEGER_1163_1_0; i < nfaces; i+=cascadedetectcpp_INTEGER_1163_2_1 )
! {
! const FeatureEvaluator::ScaleData& s = featureEvaluator->getScaleData(fptr[i*cascadedetectcpp_INTEGER_1165_1_3 + cascadedetectcpp_INTEGER_1165_2_1]);
! candidates.push_back(Rect(cvRound(fptr[i*cascadedetectcpp_INTEGER_1166_1_3 + cascadedetectcpp_INTEGER_1166_2_2]*s.scale),
! cvRound(fptr[i*cascadedetectcpp_INTEGER_1167_1_3 + cascadedetectcpp_INTEGER_1167_2_3]*s.scale),
! cvRound(data.origWinSize.width*s.scale),
! cvRound(data.origWinSize.height*s.scale)));
! }
! }
! return ok;
  }
  #endif
  
  bool CascadeClassifierImpl::isOldFormatCascade() const
  {
! return !oldCascade.empty();
  }
  
  int CascadeClassifierImpl::getFeatureType() const
  {
! return featureEvaluator->getFeatureType();
  }
  
  Size CascadeClassifierImpl::getOriginalWindowSize() const
  {
! return data.origWinSize;
  }
  
  void* CascadeClassifierImpl::getOldCascade()
  {
! return oldCascade;
  }
  
  static void detectMultiScaleOldFormat( const Mat& image, Ptr<CvHaarClassifierCascade> oldCascade,
! std::vector<Rect>& objects,
! std::vector<int>& rejectLevels,
! std::vector<double>& levelWeights,
! std::vector<CvAvgComp>& vecAvgComp,
! double scaleFactor, int minNeighbors,
! int flags, Size minObjectSize, Size maxObjectSize,
! bool outputRejectLevels = false )
! {
! MemStorage storage(cvCreateMemStorage(cascadedetectcpp_INTEGER_1205_1_0));
! CvMat _image = image;
! CvSeq* _objects = cvHaarDetectObjectsForROC( &_image, oldCascade, storage, rejectLevels, levelWeights, scaleFactor,
! minNeighbors, flags, minObjectSize, maxObjectSize, outputRejectLevels );
! Seq<CvAvgComp>(_objects).copyTo(vecAvgComp);
! objects.resize(vecAvgComp.size());
! std::transform(vecAvgComp.begin(), vecAvgComp.end(), objects.begin(), getRect());
  }
  
  
  void CascadeClassifierImpl::detectMultiScaleNoGrouping( InputArray _image, std::vector<Rect>& candidates,
! std::vector<int>& rejectLevels, std::vector<double>& levelWeights,
! double scaleFactor, Size minObjectSize, Size maxObjectSize,
! bool outputRejectLevels )
  {
! Size imgsz = _image.size();
  
! Mat grayImage;
! _InputArray gray;
  
! candidates.clear();
! rejectLevels.clear();
! levelWeights.clear();
  
! if( maxObjectSize.height == cascadedetectcpp_INTEGER_1229_1_0 || maxObjectSize.width == cascadedetectcpp_INTEGER_1229_2_0 )
! maxObjectSize = imgsz;
  
  #ifdef HAVE_OPENCL
! bool use_ocl = tryOpenCL && ocl::useOpenCL() &&
! featureEvaluator->getLocalSize().area() > cascadedetectcpp_INTEGER_1234_1_0 &&
! ocl::Device::getDefault().type() != ocl::Device::TYPE_CPU &&
! (data.minNodesPerTree == data.maxNodesPerTree) &&
! !isOldFormatCascade() &&
! maskGenerator.empty() &&
! !outputRejectLevels;
  #endif
  
! /*if( use_ocl )
! {
! if (_image.channels() > cascadedetectcpp_INTEGER_1244_1_1)
! cvtColor(_image, ugrayImage, COLOR_BGR2GRAY);
! else if (_image.isUMat())
! ugrayImage = _image.getUMat();
! else
! _image.copyTo(ugrayImage);
! gray = ugrayImage;
! }
! else*/
! {
! if (_image.channels() > cascadedetectcpp_INTEGER_1254_1_1)
! cvtColor(_image, grayImage, COLOR_BGR2GRAY);
! else if (_image.isMat())
! grayImage = _image.getMat();
! else
! _image.copyTo(grayImage);
! gray = grayImage;
! }
! 
! std::vector<float> scales;
! scales.reserve(cascadedetectcpp_INTEGER_1264_1_1024);
  
! for( double factor = cascadedetectcpp_INTEGER_1266_1_1; ; factor *= scaleFactor )
! {
! Size originalWindowSize = getOriginalWindowSize();
! 
! Size windowSize( cvRound(originalWindowSize.width*factor), cvRound(originalWindowSize.height*factor) );
! if( windowSize.width > maxObjectSize.width || windowSize.height > maxObjectSize.height ||
! windowSize.width > imgsz.width || windowSize.height > imgsz.height )
! break;
! if( windowSize.width < minObjectSize.width || windowSize.height < minObjectSize.height )
! continue;
! scales.push_back((float)factor);
! }
! 
! if( scales.size() == cascadedetectcpp_INTEGER_1279_1_0 || !featureEvaluator->setImage(gray, scales) )
! return;
  
  #ifdef HAVE_OPENCL
! // OpenCL code
! CV_OCL_RUN(use_ocl, ocl_detectMultiScaleNoGrouping( scales, candidates ))
  
! tryOpenCL = false;
  #endif
  
! // CPU code
! featureEvaluator->getMats();
! {
! Mat currentMask;
! if (maskGenerator)
! currentMask = maskGenerator->generateMask(gray.getMat());
! 
! size_t i, nscales = scales.size();
! cv::AutoBuffer<int> stripeSizeBuf(nscales);
! int* stripeSizes = stripeSizeBuf;
! const FeatureEvaluator::ScaleData* s = &featureEvaluator->getScaleData(cascadedetectcpp_INTEGER_1299_1_0);
! Size szw = s->getWorkingSize(data.origWinSize);
! int nstripes = cvCeil(szw.width/32.);
! for( i = cascadedetectcpp_INTEGER_1302_1_0; i < nscales; i+=cascadedetectcpp_INTEGER_1302_2_1 )
! {
! szw = s[i].getWorkingSize(data.origWinSize);
! stripeSizes[i] = std::max((szw.height/s[i].ystep + nstripes-cascadedetectcpp_INTEGER_1305_1_1)/nstripes, cascadedetectcpp_INTEGER_1305_2_1)*s[i].ystep;
! }
! 
! CascadeClassifierInvoker invoker(*this, (int)nscales, nstripes, s, stripeSizes,
! candidates, rejectLevels, levelWeights,
! outputRejectLevels, currentMask, &mtx);
! parallel_for_(Range(cascadedetectcpp_INTEGER_1311_1_0, nstripes), invoker);
! }
  }
  
  
  void CascadeClassifierImpl::detectMultiScale( InputArray _image, std::vector<Rect>& objects,
! std::vector<int>& rejectLevels,
! std::vector<double>& levelWeights,
! double scaleFactor, int minNeighbors,
! int flags, Size minObjectSize, Size maxObjectSize,
! bool outputRejectLevels )
! {
! CV_Assert( scaleFactor > cascadedetectcpp_INTEGER_1323_1_1 && _image.depth() == CV_8U );
! 
! if( empty() )
! return;
! 
! if( isOldFormatCascade() )
! {
! Mat image = _image.getMat();
! std::vector<CvAvgComp> fakeVecAvgComp;
! detectMultiScaleOldFormat( image, oldCascade, objects, rejectLevels, levelWeights, fakeVecAvgComp, scaleFactor,
! minNeighbors, flags, minObjectSize, maxObjectSize, outputRejectLevels );
! }
! else
! {
! detectMultiScaleNoGrouping( _image, objects, rejectLevels, levelWeights, scaleFactor, minObjectSize, maxObjectSize,
! outputRejectLevels );
! const double GROUP_EPS = 0.2;
! if( outputRejectLevels )
! {
! groupRectangles( objects, rejectLevels, levelWeights, minNeighbors, GROUP_EPS );
! }
! else
! {
! groupRectangles( objects, minNeighbors, GROUP_EPS );
! }
! }
  }
  
  void CascadeClassifierImpl::detectMultiScale( InputArray _image, std::vector<Rect>& objects,
! double scaleFactor, int minNeighbors,
! int flags, Size minObjectSize, Size maxObjectSize)
  {
! std::vector<int> fakeLevels;
! std::vector<double> fakeWeights;
! detectMultiScale( _image, objects, fakeLevels, fakeWeights, scaleFactor,
! minNeighbors, flags, minObjectSize, maxObjectSize );
  }
  
  void CascadeClassifierImpl::detectMultiScale( InputArray _image, std::vector<Rect>& objects,
! std::vector<int>& numDetections, double scaleFactor,
! int minNeighbors, int flags, Size minObjectSize,
! Size maxObjectSize )
! {
! Mat image = _image.getMat();
! CV_Assert( scaleFactor > cascadedetectcpp_INTEGER_1367_1_1 && image.depth() == CV_8U );
! 
! if( empty() )
! return;
! 
! std::vector<int> fakeLevels;
! std::vector<double> fakeWeights;
! if( isOldFormatCascade() )
! {
! std::vector<CvAvgComp> vecAvgComp;
! detectMultiScaleOldFormat( image, oldCascade, objects, fakeLevels, fakeWeights, vecAvgComp, scaleFactor,
! minNeighbors, flags, minObjectSize, maxObjectSize );
! numDetections.resize(vecAvgComp.size());
! std::transform(vecAvgComp.begin(), vecAvgComp.end(), numDetections.begin(), getNeighbors());
! }
! else
! {
! detectMultiScaleNoGrouping( image, objects, fakeLevels, fakeWeights, scaleFactor, minObjectSize, maxObjectSize );
! const double GROUP_EPS = 0.2;
! groupRectangles( objects, numDetections, minNeighbors, GROUP_EPS );
! }
  }
  
  
  CascadeClassifierImpl::Data::Data()
  {
! stageType = featureType = ncategories = maxNodesPerTree = cascadedetectcpp_INTEGER_1393_1_0;
  }
  
  bool CascadeClassifierImpl::Data::read(const FileNode &root)
  {
! static const float THRESHOLD_EPS = 1e-5f;
! 
! // load stage params
! String stageTypeStr = (String)root[CC_STAGE_TYPE];
! if( stageTypeStr == CC_BOOST )
! stageType = BOOST;
! else
! return false;
! 
! String featureTypeStr = (String)root[CC_FEATURE_TYPE];
! if( featureTypeStr == CC_HAAR )
! featureType = FeatureEvaluator::HAAR;
! else if( featureTypeStr == CC_LBP )
! featureType = FeatureEvaluator::LBP;
! else if( featureTypeStr == CC_HOG )
! {
! featureType = FeatureEvaluator::HOG;
! CV_Error(Error::StsNotImplemented, "HOG cascade is not supported in 3.0");
! }
! else
! return false;
! 
! origWinSize.width = (int)root[CC_WIDTH];
! origWinSize.height = (int)root[CC_HEIGHT];
! CV_Assert( origWinSize.height > cascadedetectcpp_INTEGER_1422_1_0 && origWinSize.width > cascadedetectcpp_INTEGER_1422_2_0 );
! 
! // load feature params
! FileNode fn = root[CC_FEATURE_PARAMS];
! if( fn.empty() )
! return false;
! 
! ncategories = fn[CC_MAX_CAT_COUNT];
! int subsetSize = (ncategories + cascadedetectcpp_INTEGER_1430_1_31)/cascadedetectcpp_INTEGER_1430_2_32,
! nodeStep = cascadedetectcpp_INTEGER_1431_1_3 + ( ncategories>cascadedetectcpp_INTEGER_1431_2_0 ? subsetSize : cascadedetectcpp_INTEGER_1431_3_1 );
! 
! // load stages
! fn = root[CC_STAGES];
! if( fn.empty() )
! return false;
! 
! stages.reserve(fn.size());
! classifiers.clear();
! nodes.clear();
! stumps.clear();
! 
! FileNodeIterator it = fn.begin(), it_end = fn.end();
! minNodesPerTree = INT_MAX;
! maxNodesPerTree = cascadedetectcpp_INTEGER_1445_1_0;
! 
! for( int si = cascadedetectcpp_INTEGER_1447_1_0; it != it_end; si+=cascadedetectcpp_INTEGER_1447_2_1, ++it )
! {
! FileNode fns = *it;
! Stage stage;
! stage.threshold = (float)fns[CC_STAGE_THRESHOLD] - THRESHOLD_EPS;
! fns = fns[CC_WEAK_CLASSIFIERS];
! if(fns.empty())
! return false;
! stage.ntrees = (int)fns.size();
! stage.first = (int)classifiers.size();
! stages.push_back(stage);
! classifiers.reserve(stages[si].first + stages[si].ntrees);
! 
! FileNodeIterator it1 = fns.begin(), it1_end = fns.end();
! for( ; it1 != it1_end; ++it1 ) // weak trees
! {
! FileNode fnw = *it1;
! FileNode internalNodes = fnw[CC_INTERNAL_NODES];
! FileNode leafValues = fnw[CC_LEAF_VALUES];
! if( internalNodes.empty() || leafValues.empty() )
! return false;
! 
! DTree tree;
! tree.nodeCount = (int)internalNodes.size()/nodeStep;
! minNodesPerTree = std::min(minNodesPerTree, tree.nodeCount);
! maxNodesPerTree = std::max(maxNodesPerTree, tree.nodeCount);
! 
! classifiers.push_back(tree);
! 
! nodes.reserve(nodes.size() + tree.nodeCount);
! leaves.reserve(leaves.size() + leafValues.size());
! if( subsetSize > cascadedetectcpp_INTEGER_1478_1_0 )
! subsets.reserve(subsets.size() + tree.nodeCount*subsetSize);
! 
! FileNodeIterator internalNodesIter = internalNodes.begin(), internalNodesEnd = internalNodes.end();
! 
! for( ; internalNodesIter != internalNodesEnd; ) // nodes
! {
! DTreeNode node;
! node.left = (int)*internalNodesIter; ++internalNodesIter;
! node.right = (int)*internalNodesIter; ++internalNodesIter;
! node.featureIdx = (int)*internalNodesIter; ++internalNodesIter;
! if( subsetSize > cascadedetectcpp_INTEGER_1489_1_0 )
! {
! for( int j = cascadedetectcpp_INTEGER_1491_1_0; j < subsetSize; j+=cascadedetectcpp_INTEGER_1491_2_1, ++internalNodesIter )
! subsets.push_back((int)*internalNodesIter);
! node.threshold = 0.f;
! }
! else
! {
! node.threshold = (float)*internalNodesIter; ++internalNodesIter;
! }
! nodes.push_back(node);
! }
! 
! internalNodesIter = leafValues.begin(), internalNodesEnd = leafValues.end();
  
! for( ; internalNodesIter != internalNodesEnd; ++internalNodesIter ) // leaves
! leaves.push_back((float)*internalNodesIter);
! }
! }
! 
! if( maxNodesPerTree == cascadedetectcpp_INTEGER_1509_1_1 )
! {
! int nodeOfs = cascadedetectcpp_INTEGER_1511_1_0, leafOfs = cascadedetectcpp_INTEGER_1511_2_0;
! size_t nstages = stages.size();
! for( size_t stageIdx = cascadedetectcpp_INTEGER_1513_1_0; stageIdx < nstages; stageIdx+=cascadedetectcpp_INTEGER_1513_2_1 )
! {
! const Stage& stage = stages[stageIdx];
! 
! int ntrees = stage.ntrees;
! for( int i = cascadedetectcpp_INTEGER_1518_1_0; i < ntrees; i+=cascadedetectcpp_INTEGER_1518_2_1, nodeOfs+=cascadedetectcpp_INTEGER_1518_3_1, leafOfs+= cascadedetectcpp_INTEGER_1518_4_2 )
! {
! const DTreeNode& node = nodes[nodeOfs];
! stumps.push_back(Stump(node.featureIdx, node.threshold,
! leaves[leafOfs], leaves[leafOfs+cascadedetectcpp_INTEGER_1522_1_1]));
! }
! }
! }
  
! return true;
  }
  
  
  bool CascadeClassifierImpl::read_(const FileNode& root)
  {
  #ifdef HAVE_OPENCL
! tryOpenCL = true;
! haarKernel = ocl::Kernel();
! lbpKernel = ocl::Kernel();
  #endif
! ustages.release();
! unodes.release();
! uleaves.release();
! if( !data.read(root) )
! return false;
! 
! // load features
! featureEvaluator = FeatureEvaluator::create(data.featureType);
! FileNode fn = root[CC_FEATURES];
! if( fn.empty() )
! return false;
  
! return featureEvaluator->read(fn, data.origWinSize);
  }
  
  template<> void DefaultDeleter<CvHaarClassifierCascade>::operator ()(CvHaarClassifierCascade* obj) const
***************
*** 1561,1567 ****
  CascadeClassifier::CascadeClassifier() {}
  CascadeClassifier::CascadeClassifier(const String& filename)
  {
!     load(filename);
  }
  
  CascadeClassifier::~CascadeClassifier()
--- 1562,1568 ----
  CascadeClassifier::CascadeClassifier() {}
  CascadeClassifier::CascadeClassifier(const String& filename)
  {
! load(filename);
  }
  
  CascadeClassifier::~CascadeClassifier()
***************
*** 1570,1709 ****
  
  bool CascadeClassifier::empty() const
  {
!     return cc.empty() || cc->empty();
  }
  
  bool CascadeClassifier::load( const String& filename )
  {
!     cc = makePtr<CascadeClassifierImpl>();
!     if(!cc->load(filename))
!         cc.release();
!     return !empty();
  }
  
  bool CascadeClassifier::read(const FileNode &root)
  {
!     Ptr<CascadeClassifierImpl> ccimpl = makePtr<CascadeClassifierImpl>();
!     bool ok = ccimpl->read_(root);
!     if( ok )
!         cc = ccimpl.staticCast<BaseCascadeClassifier>();
!     else
!         cc.release();
!     return ok;
  }
  
  void clipObjects(Size sz, std::vector<Rect>& objects,
!                  std::vector<int>* a, std::vector<double>* b)
  {
!     size_t i, j = 0, n = objects.size();
!     Rect win0 = Rect(0, 0, sz.width, sz.height);
!     if(a)
!     {
!         CV_Assert(a->size() == n);
!     }
!     if(b)
!     {
!         CV_Assert(b->size() == n);
!     }
! 
!     for( i = 0; i < n; i++ )
!     {
!         Rect r = win0 & objects[i];
!         if( r.area() > 0 )
!         {
!             objects[j] = r;
!             if( i > j )
!             {
!                 if(a) a->at(j) = a->at(i);
!                 if(b) b->at(j) = b->at(i);
!             }
!             j++;
!         }
!     }
! 
!     if( j < n )
!     {
!         objects.resize(j);
!         if(a) a->resize(j);
!         if(b) b->resize(j);
!     }
  }
  
  void CascadeClassifier::detectMultiScale( InputArray image,
!                       CV_OUT std::vector<Rect>& objects,
!                       double scaleFactor,
!                       int minNeighbors, int flags,
!                       Size minSize,
!                       Size maxSize )
! {
!     CV_Assert(!empty());
!     cc->detectMultiScale(image, objects, scaleFactor, minNeighbors, flags, minSize, maxSize);
!     clipObjects(image.size(), objects, 0, 0);
  }
  
  void CascadeClassifier::detectMultiScale( InputArray image,
!                       CV_OUT std::vector<Rect>& objects,
!                       CV_OUT std::vector<int>& numDetections,
!                       double scaleFactor,
!                       int minNeighbors, int flags,
!                       Size minSize, Size maxSize )
! {
!     CV_Assert(!empty());
!     cc->detectMultiScale(image, objects, numDetections,
!                          scaleFactor, minNeighbors, flags, minSize, maxSize);
!     clipObjects(image.size(), objects, &numDetections, 0);
  }
  
  void CascadeClassifier::detectMultiScale( InputArray image,
!                       CV_OUT std::vector<Rect>& objects,
!                       CV_OUT std::vector<int>& rejectLevels,
!                       CV_OUT std::vector<double>& levelWeights,
!                       double scaleFactor,
!                       int minNeighbors, int flags,
!                       Size minSize, Size maxSize,
!                       bool outputRejectLevels )
! {
!     CV_Assert(!empty());
!     cc->detectMultiScale(image, objects, rejectLevels, levelWeights,
!                          scaleFactor, minNeighbors, flags,
!                          minSize, maxSize, outputRejectLevels);
!     clipObjects(image.size(), objects, &rejectLevels, &levelWeights);
  }
  
  bool CascadeClassifier::isOldFormatCascade() const
  {
!     CV_Assert(!empty());
!     return cc->isOldFormatCascade();
  }
  
  Size CascadeClassifier::getOriginalWindowSize() const
  {
!     CV_Assert(!empty());
!     return cc->getOriginalWindowSize();
  }
  
  int CascadeClassifier::getFeatureType() const
  {
!     CV_Assert(!empty());
!     return cc->getFeatureType();
  }
  
  void* CascadeClassifier::getOldCascade()
  {
!     CV_Assert(!empty());
!     return cc->getOldCascade();
  }
  
  void CascadeClassifier::setMaskGenerator(const Ptr<BaseCascadeClassifier::MaskGenerator>& maskGenerator)
  {
!     CV_Assert(!empty());
!     cc->setMaskGenerator(maskGenerator);
  }
  
  Ptr<BaseCascadeClassifier::MaskGenerator> CascadeClassifier::getMaskGenerator()
  {
!     CV_Assert(!empty());
!     return cc->getMaskGenerator();
  }
  
  } // namespace cv
--- 1571,1710 ----
  
  bool CascadeClassifier::empty() const
  {
! return cc.empty() || cc->empty();
  }
  
  bool CascadeClassifier::load( const String& filename )
  {
! cc = makePtr<CascadeClassifierImpl>();
! if(!cc->load(filename))
! cc.release();
! return !empty();
  }
  
  bool CascadeClassifier::read(const FileNode &root)
  {
! Ptr<CascadeClassifierImpl> ccimpl = makePtr<CascadeClassifierImpl>();
! bool ok = ccimpl->read_(root);
! if( ok )
! cc = ccimpl.staticCast<BaseCascadeClassifier>();
! else
! cc.release();
! return ok;
  }
  
  void clipObjects(Size sz, std::vector<Rect>& objects,
! std::vector<int>* a, std::vector<double>* b)
! {
! size_t i, j = cascadedetectcpp_INTEGER_1598_1_0, n = objects.size();
! Rect win0 = Rect(cascadedetectcpp_INTEGER_1599_1_0, cascadedetectcpp_INTEGER_1599_2_0, sz.width, sz.height);
! if(a)
! {
! CV_Assert(a->size() == n);
! }
! if(b)
! {
! CV_Assert(b->size() == n);
! }
! 
! for( i = cascadedetectcpp_INTEGER_1609_1_0; i < n; i+=cascadedetectcpp_INTEGER_1609_2_1 )
! {
! Rect r = win0 & objects[i];
! if( r.area() > cascadedetectcpp_INTEGER_1612_1_0 )
  {
! objects[j] = r;
! if( i > j )
! {
! if(a) a->at(j) = a->at(i);
! if(b) b->at(j) = b->at(i);
! }
! j+=cascadedetectcpp_INTEGER_1620_1_1;
! }
! }
! 
! if( j < n )
! {
! objects.resize(j);
! if(a) a->resize(j);
! if(b) b->resize(j);
! }
  }
  
  void CascadeClassifier::detectMultiScale( InputArray image,
! CV_OUT std::vector<Rect>& objects,
! double scaleFactor,
! int minNeighbors, int flags,
! Size minSize,
! Size maxSize )
! {
! CV_Assert(!empty());
! cc->detectMultiScale(image, objects, scaleFactor, minNeighbors, flags, minSize, maxSize);
! clipObjects(image.size(), objects, cascadedetectcpp_INTEGER_1641_1_0, cascadedetectcpp_INTEGER_1641_2_0);
  }
  
  void CascadeClassifier::detectMultiScale( InputArray image,
! CV_OUT std::vector<Rect>& objects,
! CV_OUT std::vector<int>& numDetections,
! double scaleFactor,
! int minNeighbors, int flags,
! Size minSize, Size maxSize )
! {
! CV_Assert(!empty());
! cc->detectMultiScale(image, objects, numDetections,
! scaleFactor, minNeighbors, flags, minSize, maxSize);
! clipObjects(image.size(), objects, &numDetections, cascadedetectcpp_INTEGER_1654_1_0);
  }
  
  void CascadeClassifier::detectMultiScale( InputArray image,
! CV_OUT std::vector<Rect>& objects,
! CV_OUT std::vector<int>& rejectLevels,
! CV_OUT std::vector<double>& levelWeights,
! double scaleFactor,
! int minNeighbors, int flags,
! Size minSize, Size maxSize,
! bool outputRejectLevels )
! {
! CV_Assert(!empty());
! cc->detectMultiScale(image, objects, rejectLevels, levelWeights,
! scaleFactor, minNeighbors, flags,
! minSize, maxSize, outputRejectLevels);
! clipObjects(image.size(), objects, &rejectLevels, &levelWeights);
  }
  
  bool CascadeClassifier::isOldFormatCascade() const
  {
! CV_Assert(!empty());
! return cc->isOldFormatCascade();
  }
  
  Size CascadeClassifier::getOriginalWindowSize() const
  {
! CV_Assert(!empty());
! return cc->getOriginalWindowSize();
  }
  
  int CascadeClassifier::getFeatureType() const
  {
! CV_Assert(!empty());
! return cc->getFeatureType();
  }
  
  void* CascadeClassifier::getOldCascade()
  {
! CV_Assert(!empty());
! return cc->getOldCascade();
  }
  
  void CascadeClassifier::setMaskGenerator(const Ptr<BaseCascadeClassifier::MaskGenerator>& maskGenerator)
  {
! CV_Assert(!empty());
! cc->setMaskGenerator(maskGenerator);
  }
  
  Ptr<BaseCascadeClassifier::MaskGenerator> CascadeClassifier::getMaskGenerator()
  {
! CV_Assert(!empty());
! return cc->getMaskGenerator();
  }
  
  } // namespace cv
diff -cN ../opencv_unmod/modules/objdetect/src/cascadedetect.hpp ../opencv/modules/objdetect/src/cascadedetect.hpp
*** ../opencv_unmod/modules/objdetect/src/cascadedetect.hpp	2016-04-29 00:17:16.527389999 +0000
--- ../opencv/modules/objdetect/src/cascadedetect.hpp	2016-04-19 19:18:00.067326000 +0000
***************
*** 1,3 ****
--- 1,4 ----
+ #include "replaces.hpp"
  #pragma once
  
  #include "opencv2/core/ocl.hpp"
***************
*** 6,230 ****
  {
  
  void clipObjects(Size sz, std::vector<Rect>& objects,
!                  std::vector<int>* a, std::vector<double>* b);
  
  class FeatureEvaluator
  {
  public:
!     enum
!     {
!         HAAR = 0,
!         LBP  = 1,
!         HOG  = 2
!     };
! 
!     struct ScaleData
!     {
!         ScaleData() { scale = 0.f; layer_ofs = ystep = 0; }
!         Size getWorkingSize(Size winSize) const
!         {
!             return Size(std::max(szi.width - winSize.width, 0),
!                         std::max(szi.height - winSize.height, 0));
!         }
! 
!         float scale;
!         Size szi;
!         int layer_ofs, ystep;
!     };
! 
!     virtual ~FeatureEvaluator();
! 
!     virtual bool read(const FileNode& node, Size origWinSize);
!     virtual Ptr<FeatureEvaluator> clone() const;
!     virtual int getFeatureType() const;
!     int getNumChannels() const { return nchannels; }
! 
!     virtual bool setImage(InputArray img, const std::vector<float>& scales);
!     virtual bool setWindow(Point p, int scaleIdx);
!     const ScaleData& getScaleData(int scaleIdx) const
!     {
!         CV_Assert( 0 <= scaleIdx && scaleIdx < (int)scaleData->size());
!         return scaleData->at(scaleIdx);
!     }
!     virtual void getUMats(std::vector<UMat>& bufs);
!     virtual void getMats();
  
!     Size getLocalSize() const { return localSize; }
!     Size getLocalBufSize() const { return lbufSize; }
  
!     virtual float calcOrd(int featureIdx) const;
!     virtual int calcCat(int featureIdx) const;
  
!     static Ptr<FeatureEvaluator> create(int type);
  
  protected:
!     enum { SBUF_VALID=1, USBUF_VALID=2 };
!     int sbufFlag;
  
!     bool updateScaleData( Size imgsz, const std::vector<float>& _scales );
!     virtual void computeChannels( int, InputArray ) {}
!     virtual void computeOptFeatures() {}
! 
!     Size origWinSize, sbufSize, localSize, lbufSize;
!     int nchannels;
!     Mat sbuf, rbuf;
!     UMat urbuf, usbuf, ufbuf, uscaleData;
  
!     Ptr<std::vector<ScaleData> > scaleData;
  };
  
  
  class CascadeClassifierImpl : public BaseCascadeClassifier
  {
  public:
!     CascadeClassifierImpl();
!     virtual ~CascadeClassifierImpl();
  
!     bool empty() const;
!     bool load( const String& filename );
!     void read( const FileNode& node );
!     bool read_( const FileNode& node );
!     void detectMultiScale( InputArray image,
!                           CV_OUT std::vector<Rect>& objects,
!                           double scaleFactor = 1.1,
!                           int minNeighbors = 3, int flags = 0,
!                           Size minSize = Size(),
!                           Size maxSize = Size() );
! 
!     void detectMultiScale( InputArray image,
!                           CV_OUT std::vector<Rect>& objects,
!                           CV_OUT std::vector<int>& numDetections,
!                           double scaleFactor=1.1,
!                           int minNeighbors=3, int flags=0,
!                           Size minSize=Size(),
!                           Size maxSize=Size() );
! 
!     void detectMultiScale( InputArray image,
!                           CV_OUT std::vector<Rect>& objects,
!                           CV_OUT std::vector<int>& rejectLevels,
!                           CV_OUT std::vector<double>& levelWeights,
!                           double scaleFactor = 1.1,
!                           int minNeighbors = 3, int flags = 0,
!                           Size minSize = Size(),
!                           Size maxSize = Size(),
!                           bool outputRejectLevels = false );
! 
! 
!     bool isOldFormatCascade() const;
!     Size getOriginalWindowSize() const;
!     int getFeatureType() const;
!     void* getOldCascade();
  
!     void setMaskGenerator(const Ptr<MaskGenerator>& maskGenerator);
!     Ptr<MaskGenerator> getMaskGenerator();
  
  protected:
!     enum { SUM_ALIGN = 64 };
  
!     bool detectSingleScale( InputArray image, Size processingRectSize,
!                             int yStep, double factor, std::vector<Rect>& candidates,
!                             std::vector<int>& rejectLevels, std::vector<double>& levelWeights,
!                             Size sumSize0, bool outputRejectLevels = false );
  #ifdef HAVE_OPENCL
!     bool ocl_detectMultiScaleNoGrouping( const std::vector<float>& scales,
!                                          std::vector<Rect>& candidates );
  #endif
!     void detectMultiScaleNoGrouping( InputArray image, std::vector<Rect>& candidates,
!                                     std::vector<int>& rejectLevels, std::vector<double>& levelWeights,
!                                     double scaleFactor, Size minObjectSize, Size maxObjectSize,
!                                     bool outputRejectLevels = false );
! 
!     enum { MAX_FACES = 10000 };
!     enum { BOOST = 0 };
!     enum { DO_CANNY_PRUNING    = CASCADE_DO_CANNY_PRUNING,
!         SCALE_IMAGE         = CASCADE_SCALE_IMAGE,
!         FIND_BIGGEST_OBJECT = CASCADE_FIND_BIGGEST_OBJECT,
!         DO_ROUGH_SEARCH     = CASCADE_DO_ROUGH_SEARCH
!     };
! 
!     friend class CascadeClassifierInvoker;
!     friend class SparseCascadeClassifierInvoker;
! 
!     template<class FEval>
!     friend int predictOrdered( CascadeClassifierImpl& cascade, Ptr<FeatureEvaluator> &featureEvaluator, double& weight);
! 
!     template<class FEval>
!     friend int predictCategorical( CascadeClassifierImpl& cascade, Ptr<FeatureEvaluator> &featureEvaluator, double& weight);
! 
!     template<class FEval>
!     friend int predictOrderedStump( CascadeClassifierImpl& cascade, Ptr<FeatureEvaluator> &featureEvaluator, double& weight);
! 
!     template<class FEval>
!     friend int predictCategoricalStump( CascadeClassifierImpl& cascade, Ptr<FeatureEvaluator> &featureEvaluator, double& weight);
! 
!     int runAt( Ptr<FeatureEvaluator>& feval, Point pt, int scaleIdx, double& weight );
! 
!     class Data
!     {
!     public:
!         struct DTreeNode
!         {
!             int featureIdx;
!             float threshold; // for ordered features only
!             int left;
!             int right;
!         };
! 
!         struct DTree
!         {
!             int nodeCount;
!         };
! 
!         struct Stage
!         {
!             int first;
!             int ntrees;
!             float threshold;
!         };
! 
!         struct Stump
!         {
!             Stump() { }
!             Stump(int _featureIdx, float _threshold, float _left, float _right)
!             : featureIdx(_featureIdx), threshold(_threshold), left(_left), right(_right) {}
! 
!             int featureIdx;
!             float threshold;
!             float left;
!             float right;
!         };
! 
!         Data();
! 
!         bool read(const FileNode &node);
! 
!         int stageType;
!         int featureType;
!         int ncategories;
!         int minNodesPerTree, maxNodesPerTree;
!         Size origWinSize;
! 
!         std::vector<Stage> stages;
!         std::vector<DTree> classifiers;
!         std::vector<DTreeNode> nodes;
!         std::vector<float> leaves;
!         std::vector<int> subsets;
!         std::vector<Stump> stumps;
!     };
! 
!     Data data;
!     Ptr<FeatureEvaluator> featureEvaluator;
!     Ptr<CvHaarClassifierCascade> oldCascade;
! 
!     Ptr<MaskGenerator> maskGenerator;
!     UMat ugrayImage;
!     UMat ufacepos, ustages, unodes, uleaves, usubsets;
  #ifdef HAVE_OPENCL
!     ocl::Kernel haarKernel, lbpKernel;
!     bool tryOpenCL;
  #endif
  
!     Mutex mtx;
  };
  
  #define CC_CASCADE_PARAMS "cascadeParams"
--- 7,231 ----
  {
  
  void clipObjects(Size sz, std::vector<Rect>& objects,
! std::vector<int>* a, std::vector<double>* b);
  
  class FeatureEvaluator
  {
  public:
! enum
! {
! HAAR = cascadedetecthpp_INTEGER_16_1_0,
! LBP  = cascadedetecthpp_INTEGER_17_1_1,
! HOG  = cascadedetecthpp_INTEGER_18_1_2
! };
! 
! struct ScaleData
! {
! ScaleData() { scale = 0.f; layer_ofs = ystep = cascadedetecthpp_INTEGER_23_1_0; }
! Size getWorkingSize(Size winSize) const
! {
! return Size(std::max(szi.width - winSize.width, cascadedetecthpp_INTEGER_26_1_0),
! std::max(szi.height - winSize.height, cascadedetecthpp_INTEGER_27_1_0));
! }
! 
! float scale;
! Size szi;
! int layer_ofs, ystep;
! };
! 
! virtual ~FeatureEvaluator();
! 
! virtual bool read(const FileNode& node, Size origWinSize);
! virtual Ptr<FeatureEvaluator> clone() const;
! virtual int getFeatureType() const;
! int getNumChannels() const { return nchannels; }
! 
! virtual bool setImage(InputArray img, const std::vector<float>& scales);
! virtual bool setWindow(Point p, int scaleIdx);
! const ScaleData& getScaleData(int scaleIdx) const
! {
! CV_Assert( cascadedetecthpp_INTEGER_46_1_0 <= scaleIdx && scaleIdx < (int)scaleData->size());
! return scaleData->at(scaleIdx);
! }
! virtual void getUMats(std::vector<UMat>& bufs);
! virtual void getMats();
  
! Size getLocalSize() const { return localSize; }
! Size getLocalBufSize() const { return lbufSize; }
  
! virtual float calcOrd(int featureIdx) const;
! virtual int calcCat(int featureIdx) const;
  
! static Ptr<FeatureEvaluator> create(int type);
  
  protected:
! enum { SBUF_VALID=cascadedetecthpp_INTEGER_61_1_1, USBUF_VALID=cascadedetecthpp_INTEGER_61_2_2 };
! int sbufFlag;
  
! bool updateScaleData( Size imgsz, const std::vector<float>& _scales );
! virtual void computeChannels( int, InputArray ) {}
! virtual void computeOptFeatures() {}
! 
! Size origWinSize, sbufSize, localSize, lbufSize;
! int nchannels;
! Mat sbuf, rbuf;
! UMat urbuf, usbuf, ufbuf, uscaleData;
  
! Ptr<std::vector<ScaleData> > scaleData;
  };
  
  
  class CascadeClassifierImpl : public BaseCascadeClassifier
  {
  public:
! CascadeClassifierImpl();
! virtual ~CascadeClassifierImpl();
  
! bool empty() const;
! bool load( const String& filename );
! void read( const FileNode& node );
! bool read_( const FileNode& node );
! void detectMultiScale( InputArray image,
! CV_OUT std::vector<Rect>& objects,
! double scaleFactor = 1.1,
! int minNeighbors = cascadedetecthpp_INTEGER_90_1_3, int flags = cascadedetecthpp_INTEGER_90_2_0,
! Size minSize = Size(),
! Size maxSize = Size() );
! 
! void detectMultiScale( InputArray image,
! CV_OUT std::vector<Rect>& objects,
! CV_OUT std::vector<int>& numDetections,
! double scaleFactor=1.1,
! int minNeighbors=cascadedetecthpp_INTEGER_98_1_3, int flags=cascadedetecthpp_INTEGER_98_2_0,
! Size minSize=Size(),
! Size maxSize=Size() );
! 
! void detectMultiScale( InputArray image,
! CV_OUT std::vector<Rect>& objects,
! CV_OUT std::vector<int>& rejectLevels,
! CV_OUT std::vector<double>& levelWeights,
! double scaleFactor = 1.1,
! int minNeighbors = cascadedetecthpp_INTEGER_107_1_3, int flags = cascadedetecthpp_INTEGER_107_2_0,
! Size minSize = Size(),
! Size maxSize = Size(),
! bool outputRejectLevels = false );
! 
! 
! bool isOldFormatCascade() const;
! Size getOriginalWindowSize() const;
! int getFeatureType() const;
! void* getOldCascade();
  
! void setMaskGenerator(const Ptr<MaskGenerator>& maskGenerator);
! Ptr<MaskGenerator> getMaskGenerator();
  
  protected:
! enum { SUM_ALIGN = cascadedetecthpp_INTEGER_122_1_64 };
  
! bool detectSingleScale( InputArray image, Size processingRectSize,
! int yStep, double factor, std::vector<Rect>& candidates,
! std::vector<int>& rejectLevels, std::vector<double>& levelWeights,
! Size sumSize0, bool outputRejectLevels = false );
  #ifdef HAVE_OPENCL
! bool ocl_detectMultiScaleNoGrouping( const std::vector<float>& scales,
! std::vector<Rect>& candidates );
  #endif
! void detectMultiScaleNoGrouping( InputArray image, std::vector<Rect>& candidates,
! std::vector<int>& rejectLevels, std::vector<double>& levelWeights,
! double scaleFactor, Size minObjectSize, Size maxObjectSize,
! bool outputRejectLevels = false );
! 
! enum { MAX_FACES = cascadedetecthpp_INTEGER_137_1_10000 };
! enum { BOOST = cascadedetecthpp_INTEGER_138_1_0 };
! enum { DO_CANNY_PRUNING    = CASCADE_DO_CANNY_PRUNING,
! SCALE_IMAGE         = CASCADE_SCALE_IMAGE,
! FIND_BIGGEST_OBJECT = CASCADE_FIND_BIGGEST_OBJECT,
! DO_ROUGH_SEARCH     = CASCADE_DO_ROUGH_SEARCH
! };
! 
! friend class CascadeClassifierInvoker;
! friend class SparseCascadeClassifierInvoker;
! 
! template<class FEval>
! friend int predictOrdered( CascadeClassifierImpl& cascade, Ptr<FeatureEvaluator> &featureEvaluator, double& weight);
! 
! template<class FEval>
! friend int predictCategorical( CascadeClassifierImpl& cascade, Ptr<FeatureEvaluator> &featureEvaluator, double& weight);
! 
! template<class FEval>
! friend int predictOrderedStump( CascadeClassifierImpl& cascade, Ptr<FeatureEvaluator> &featureEvaluator, double& weight);
! 
! template<class FEval>
! friend int predictCategoricalStump( CascadeClassifierImpl& cascade, Ptr<FeatureEvaluator> &featureEvaluator, double& weight);
! 
! int runAt( Ptr<FeatureEvaluator>& feval, Point pt, int scaleIdx, double& weight );
! 
! class Data
! {
! public:
! struct DTreeNode
! {
! int featureIdx;
! float threshold; // for ordered features only
! int left;
! int right;
! };
! 
! struct DTree
! {
! int nodeCount;
! };
! 
! struct Stage
! {
! int first;
! int ntrees;
! float threshold;
! };
! 
! struct Stump
! {
! Stump() { }
! Stump(int _featureIdx, float _threshold, float _left, float _right)
! : featureIdx(_featureIdx), threshold(_threshold), left(_left), right(_right) {}
! 
! int featureIdx;
! float threshold;
! float left;
! float right;
! };
! 
! Data();
! 
! bool read(const FileNode &node);
! 
! int stageType;
! int featureType;
! int ncategories;
! int minNodesPerTree, maxNodesPerTree;
! Size origWinSize;
! 
! std::vector<Stage> stages;
! std::vector<DTree> classifiers;
! std::vector<DTreeNode> nodes;
! std::vector<float> leaves;
! std::vector<int> subsets;
! std::vector<Stump> stumps;
! };
! 
! Data data;
! Ptr<FeatureEvaluator> featureEvaluator;
! Ptr<CvHaarClassifierCascade> oldCascade;
! 
! Ptr<MaskGenerator> maskGenerator;
! UMat ugrayImage;
! UMat ufacepos, ustages, unodes, uleaves, usubsets;
  #ifdef HAVE_OPENCL
! ocl::Kernel haarKernel, lbpKernel;
! bool tryOpenCL;
  #endif
  
! Mutex mtx;
  };
  
  #define CC_CASCADE_PARAMS "cascadeParams"
***************
*** 258,317 ****
  
  #define CC_HOG  "HOG"
  
! #define CV_SUM_PTRS( p0, p1, p2, p3, sum, rect, step )                    \
!     /* (x, y) */                                                          \
!     (p0) = sum + (rect).x + (step) * (rect).y,                            \
!     /* (x + w, y) */                                                      \
!     (p1) = sum + (rect).x + (rect).width + (step) * (rect).y,             \
!     /* (x + w, y) */                                                      \
!     (p2) = sum + (rect).x + (step) * ((rect).y + (rect).height),          \
!     /* (x + w, y + h) */                                                  \
!     (p3) = sum + (rect).x + (rect).width + (step) * ((rect).y + (rect).height)
! 
! #define CV_TILTED_PTRS( p0, p1, p2, p3, tilted, rect, step )                        \
!     /* (x, y) */                                                                    \
!     (p0) = tilted + (rect).x + (step) * (rect).y,                                   \
!     /* (x - h, y + h) */                                                            \
!     (p1) = tilted + (rect).x - (rect).height + (step) * ((rect).y + (rect).height), \
!     /* (x + w, y + w) */                                                            \
!     (p2) = tilted + (rect).x + (rect).width + (step) * ((rect).y + (rect).width),   \
!     /* (x + w - h, y + w + h) */                                                    \
!     (p3) = tilted + (rect).x + (rect).width - (rect).height                         \
!            + (step) * ((rect).y + (rect).width + (rect).height)
  
! #define CALC_SUM_(p0, p1, p2, p3, offset) \
!     ((p0)[offset] - (p1)[offset] - (p2)[offset] + (p3)[offset])
  
  #define CALC_SUM(rect,offset) CALC_SUM_((rect)[0], (rect)[1], (rect)[2], (rect)[3], offset)
  
! #define CV_SUM_OFS( p0, p1, p2, p3, sum, rect, step )                 \
! /* (x, y) */                                                          \
! (p0) = sum + (rect).x + (step) * (rect).y,                            \
! /* (x + w, y) */                                                      \
! (p1) = sum + (rect).x + (rect).width + (step) * (rect).y,             \
! /* (x + w, y) */                                                      \
! (p2) = sum + (rect).x + (step) * ((rect).y + (rect).height),          \
! /* (x + w, y + h) */                                                  \
! (p3) = sum + (rect).x + (rect).width + (step) * ((rect).y + (rect).height)
! 
! #define CV_TILTED_OFS( p0, p1, p2, p3, tilted, rect, step )                     \
! /* (x, y) */                                                                    \
! (p0) = tilted + (rect).x + (step) * (rect).y,                                   \
! /* (x - h, y + h) */                                                            \
! (p1) = tilted + (rect).x - (rect).height + (step) * ((rect).y + (rect).height), \
! /* (x + w, y + w) */                                                            \
! (p2) = tilted + (rect).x + (rect).width + (step) * ((rect).y + (rect).width),   \
! /* (x + w - h, y + w + h) */                                                    \
! (p3) = tilted + (rect).x + (rect).width - (rect).height                         \
! + (step) * ((rect).y + (rect).width + (rect).height)
  
! #define CALC_SUM_(p0, p1, p2, p3, offset) \
! ((p0)[offset] - (p1)[offset] - (p2)[offset] + (p3)[offset])
  
  #define CALC_SUM(rect,offset) CALC_SUM_((rect)[0], (rect)[1], (rect)[2], (rect)[3], offset)
  
! #define CALC_SUM_OFS_(p0, p1, p2, p3, ptr) \
! ((ptr)[p0] - (ptr)[p1] - (ptr)[p2] + (ptr)[p3])
  
  #define CALC_SUM_OFS(rect, ptr) CALC_SUM_OFS_((rect)[0], (rect)[1], (rect)[2], (rect)[3], ptr)
  
--- 259,281 ----
  
  #define CC_HOG  "HOG"
  
! #define CV_SUM_PTRS( p0, p1, p2, p3, sum, rect, step )                        /* (x, y) */                                                              (p0) = sum + (rect).x + (step) * (rect).y,                                /* (x + w, y) */                                                          (p1) = sum + (rect).x + (rect).width + (step) * (rect).y,                 /* (x + w, y) */                                                          (p2) = sum + (rect).x + (step) * ((rect).y + (rect).height),              /* (x + w, y + h) */                                                      (p3) = sum + (rect).x + (rect).width + (step) * ((rect).y + (rect).height)
  
! #define CV_TILTED_PTRS( p0, p1, p2, p3, tilted, rect, step )                            /* (x, y) */                                                                        (p0) = tilted + (rect).x + (step) * (rect).y,                                       /* (x - h, y + h) */                                                                (p1) = tilted + (rect).x - (rect).height + (step) * ((rect).y + (rect).height),     /* (x + w, y + w) */                                                                (p2) = tilted + (rect).x + (rect).width + (step) * ((rect).y + (rect).width),       /* (x + w - h, y + w + h) */                                                        (p3) = tilted + (rect).x + (rect).width - (rect).height                                    + (step) * ((rect).y + (rect).width + (rect).height)
! 
! #define CALC_SUM_(p0, p1, p2, p3, offset)     ((p0)[offset] - (p1)[offset] - (p2)[offset] + (p3)[offset])
  
  #define CALC_SUM(rect,offset) CALC_SUM_((rect)[0], (rect)[1], (rect)[2], (rect)[3], offset)
  
! #define CV_SUM_OFS( p0, p1, p2, p3, sum, rect, step )                 /* (x, y) */                                                          (p0) = sum + (rect).x + (step) * (rect).y,                            /* (x + w, y) */                                                      (p1) = sum + (rect).x + (rect).width + (step) * (rect).y,             /* (x + w, y) */                                                      (p2) = sum + (rect).x + (step) * ((rect).y + (rect).height),          /* (x + w, y + h) */                                                  (p3) = sum + (rect).x + (rect).width + (step) * ((rect).y + (rect).height)
! 
! #define CV_TILTED_OFS( p0, p1, p2, p3, tilted, rect, step )                     /* (x, y) */                                                                    (p0) = tilted + (rect).x + (step) * (rect).y,                                   /* (x - h, y + h) */                                                            (p1) = tilted + (rect).x - (rect).height + (step) * ((rect).y + (rect).height), /* (x + w, y + w) */                                                            (p2) = tilted + (rect).x + (rect).width + (step) * ((rect).y + (rect).width),   /* (x + w - h, y + w + h) */                                                    (p3) = tilted + (rect).x + (rect).width - (rect).height                         + (step) * ((rect).y + (rect).width + (rect).height)
  
! #define CALC_SUM_(p0, p1, p2, p3, offset) ((p0)[offset] - (p1)[offset] - (p2)[offset] + (p3)[offset])
  
  #define CALC_SUM(rect,offset) CALC_SUM_((rect)[0], (rect)[1], (rect)[2], (rect)[3], offset)
  
! #define CALC_SUM_OFS_(p0, p1, p2, p3, ptr) ((ptr)[p0] - (ptr)[p1] - (ptr)[p2] + (ptr)[p3])
  
  #define CALC_SUM_OFS(rect, ptr) CALC_SUM_OFS_((rect)[0], (rect)[1], (rect)[2], (rect)[3], ptr)
  
***************
*** 319,409 ****
  class HaarEvaluator : public FeatureEvaluator
  {
  public:
!     struct Feature
!     {
!         Feature();
!         bool read( const FileNode& node );
! 
!         bool tilted;
! 
!         enum { RECT_NUM = 3 };
!         struct
!         {
!             Rect r;
!             float weight;
!         } rect[RECT_NUM];
!     };
! 
!     struct OptFeature
!     {
!         OptFeature();
! 
!         enum { RECT_NUM = Feature::RECT_NUM };
!         float calc( const int* pwin ) const;
!         void setOffsets( const Feature& _f, int step, int tofs );
! 
!         int ofs[RECT_NUM][4];
!         float weight[4];
!     };
! 
!     HaarEvaluator();
!     virtual ~HaarEvaluator();
! 
!     virtual bool read( const FileNode& node, Size origWinSize);
!     virtual Ptr<FeatureEvaluator> clone() const;
!     virtual int getFeatureType() const { return FeatureEvaluator::HAAR; }
! 
!     virtual bool setWindow(Point p, int scaleIdx);
!     Rect getNormRect() const;
!     int getSquaresOffset() const;
! 
!     float operator()(int featureIdx) const
!     { return optfeaturesPtr[featureIdx].calc(pwin) * varianceNormFactor; }
!     virtual float calcOrd(int featureIdx) const
!     { return (*this)(featureIdx); }
  
  protected:
!     virtual void computeChannels( int i, InputArray img );
!     virtual void computeOptFeatures();
  
!     Ptr<std::vector<Feature> > features;
!     Ptr<std::vector<OptFeature> > optfeatures;
!     Ptr<std::vector<OptFeature> > optfeatures_lbuf;
!     bool hasTiltedFeatures;
! 
!     int tofs, sqofs;
!     Vec4i nofs;
!     Rect normrect;
!     const int* pwin;
!     OptFeature* optfeaturesPtr; // optimization
!     float varianceNormFactor;
  };
  
  inline HaarEvaluator::Feature :: Feature()
  {
!     tilted = false;
!     rect[0].r = rect[1].r = rect[2].r = Rect();
!     rect[0].weight = rect[1].weight = rect[2].weight = 0;
  }
  
  inline HaarEvaluator::OptFeature :: OptFeature()
  {
!     weight[0] = weight[1] = weight[2] = 0.f;
  
!     ofs[0][0] = ofs[0][1] = ofs[0][2] = ofs[0][3] =
!     ofs[1][0] = ofs[1][1] = ofs[1][2] = ofs[1][3] =
!     ofs[2][0] = ofs[2][1] = ofs[2][2] = ofs[2][3] = 0;
  }
  
  inline float HaarEvaluator::OptFeature :: calc( const int* ptr ) const
  {
!     float ret = weight[0] * CALC_SUM_OFS(ofs[0], ptr) +
!                 weight[1] * CALC_SUM_OFS(ofs[1], ptr);
  
!     if( weight[2] != 0.0f )
!         ret += weight[2] * CALC_SUM_OFS(ofs[2], ptr);
  
!     return ret;
  }
  
  //----------------------------------------------  LBPEvaluator -------------------------------------
--- 283,373 ----
  class HaarEvaluator : public FeatureEvaluator
  {
  public:
! struct Feature
! {
! Feature();
! bool read( const FileNode& node );
! 
! bool tilted;
! 
! enum { RECT_NUM = 3 };
! struct
! {
! Rect r;
! float weight;
! } rect[RECT_NUM];
! };
! 
! struct OptFeature
! {
! OptFeature();
! 
! enum { RECT_NUM = Feature::RECT_NUM };
! float calc( const int* pwin ) const;
! void setOffsets( const Feature& _f, int step, int tofs );
! 
! int ofs[RECT_NUM][4];
! float weight[4];
! };
! 
! HaarEvaluator();
! virtual ~HaarEvaluator();
! 
! virtual bool read( const FileNode& node, Size origWinSize);
! virtual Ptr<FeatureEvaluator> clone() const;
! virtual int getFeatureType() const { return FeatureEvaluator::HAAR; }
! 
! virtual bool setWindow(Point p, int scaleIdx);
! Rect getNormRect() const;
! int getSquaresOffset() const;
! 
! float operator()(int featureIdx) const
! { return optfeaturesPtr[featureIdx].calc(pwin) * varianceNormFactor; }
! virtual float calcOrd(int featureIdx) const
! { return (*this)(featureIdx); }
  
  protected:
! virtual void computeChannels( int i, InputArray img );
! virtual void computeOptFeatures();
  
! Ptr<std::vector<Feature> > features;
! Ptr<std::vector<OptFeature> > optfeatures;
! Ptr<std::vector<OptFeature> > optfeatures_lbuf;
! bool hasTiltedFeatures;
! 
! int tofs, sqofs;
! Vec4i nofs;
! Rect normrect;
! const int* pwin;
! OptFeature* optfeaturesPtr; // optimization
! float varianceNormFactor;
  };
  
  inline HaarEvaluator::Feature :: Feature()
  {
! tilted = false;
! rect[0].r = rect[1].r = rect[2].r = Rect();
! rect[0].weight = rect[1].weight = rect[2].weight = 0;
  }
  
  inline HaarEvaluator::OptFeature :: OptFeature()
  {
! weight[0] = weight[1] = weight[2] = 0.f;
  
! ofs[0][0] = ofs[0][1] = ofs[0][2] = ofs[0][3] =
! ofs[1][0] = ofs[1][1] = ofs[1][2] = ofs[1][3] =
! ofs[2][0] = ofs[2][1] = ofs[2][2] = ofs[2][3] = 0;
  }
  
  inline float HaarEvaluator::OptFeature :: calc( const int* ptr ) const
  {
! float ret = weight[0] * CALC_SUM_OFS(ofs[0], ptr) +
! weight[1] * CALC_SUM_OFS(ofs[1], ptr);
  
! if( weight[2] != 0.0f )
! ret += weight[2] * CALC_SUM_OFS(ofs[2], ptr);
  
! return ret;
  }
  
  //----------------------------------------------  LBPEvaluator -------------------------------------
***************
*** 411,485 ****
  class LBPEvaluator : public FeatureEvaluator
  {
  public:
!     struct Feature
!     {
!         Feature();
!         Feature( int x, int y, int _block_w, int _block_h  ) :
!                  rect(x, y, _block_w, _block_h) {}
! 
!         bool read(const FileNode& node );
! 
!         Rect rect; // weight and height for block
!     };
! 
!     struct OptFeature
!     {
!         OptFeature();
! 
!         int calc( const int* pwin ) const;
!         void setOffsets( const Feature& _f, int step );
!         int ofs[16];
!     };
! 
!     LBPEvaluator();
!     virtual ~LBPEvaluator();
! 
!     virtual bool read( const FileNode& node, Size origWinSize );
!     virtual Ptr<FeatureEvaluator> clone() const;
!     virtual int getFeatureType() const { return FeatureEvaluator::LBP; }
! 
!     virtual bool setWindow(Point p, int scaleIdx);
! 
!     int operator()(int featureIdx) const
!     { return optfeaturesPtr[featureIdx].calc(pwin); }
!     virtual int calcCat(int featureIdx) const
!     { return (*this)(featureIdx); }
  protected:
!     virtual void computeChannels( int i, InputArray img );
!     virtual void computeOptFeatures();
  
!     Ptr<std::vector<Feature> > features;
!     Ptr<std::vector<OptFeature> > optfeatures;
!     Ptr<std::vector<OptFeature> > optfeatures_lbuf;
!     OptFeature* optfeaturesPtr; // optimization
  
!     const int* pwin;
  };
  
  
  inline LBPEvaluator::Feature :: Feature()
  {
!     rect = Rect();
  }
  
  inline LBPEvaluator::OptFeature :: OptFeature()
  {
!     for( int i = 0; i < 16; i++ )
!         ofs[i] = 0;
  }
  
  inline int LBPEvaluator::OptFeature :: calc( const int* p ) const
  {
!     int cval = CALC_SUM_OFS_( ofs[5], ofs[6], ofs[9], ofs[10], p );
  
!     return (CALC_SUM_OFS_( ofs[0], ofs[1], ofs[4], ofs[5], p ) >= cval ? 128 : 0) |   // 0
!            (CALC_SUM_OFS_( ofs[1], ofs[2], ofs[5], ofs[6], p ) >= cval ? 64 : 0) |    // 1
!            (CALC_SUM_OFS_( ofs[2], ofs[3], ofs[6], ofs[7], p ) >= cval ? 32 : 0) |    // 2
!            (CALC_SUM_OFS_( ofs[6], ofs[7], ofs[10], ofs[11], p ) >= cval ? 16 : 0) |  // 5
!            (CALC_SUM_OFS_( ofs[10], ofs[11], ofs[14], ofs[15], p ) >= cval ? 8 : 0)|  // 8
!            (CALC_SUM_OFS_( ofs[9], ofs[10], ofs[13], ofs[14], p ) >= cval ? 4 : 0)|   // 7
!            (CALC_SUM_OFS_( ofs[8], ofs[9], ofs[12], ofs[13], p ) >= cval ? 2 : 0)|    // 6
!            (CALC_SUM_OFS_( ofs[4], ofs[5], ofs[8], ofs[9], p ) >= cval ? 1 : 0);
  }
  
  
--- 375,449 ----
  class LBPEvaluator : public FeatureEvaluator
  {
  public:
! struct Feature
! {
! Feature();
! Feature( int x, int y, int _block_w, int _block_h  ) :
! rect(x, y, _block_w, _block_h) {}
! 
! bool read(const FileNode& node );
! 
! Rect rect; // weight and height for block
! };
! 
! struct OptFeature
! {
! OptFeature();
! 
! int calc( const int* pwin ) const;
! void setOffsets( const Feature& _f, int step );
! int ofs[cascadedetecthpp_INTEGER_394_1_1];
! };
! 
! LBPEvaluator();
! virtual ~LBPEvaluator();
! 
! virtual bool read( const FileNode& node, Size origWinSize );
! virtual Ptr<FeatureEvaluator> clone() const;
! virtual int getFeatureType() const { return FeatureEvaluator::LBP; }
! 
! virtual bool setWindow(Point p, int scaleIdx);
! 
! int operator()(int featureIdx) const
! { return optfeaturesPtr[featureIdx].calc(pwin); }
! virtual int calcCat(int featureIdx) const
! { return (*this)(featureIdx); }
  protected:
! virtual void computeChannels( int i, InputArray img );
! virtual void computeOptFeatures();
  
! Ptr<std::vector<Feature> > features;
! Ptr<std::vector<OptFeature> > optfeatures;
! Ptr<std::vector<OptFeature> > optfeatures_lbuf;
! OptFeature* optfeaturesPtr; // optimization
  
! const int* pwin;
  };
  
  
  inline LBPEvaluator::Feature :: Feature()
  {
! rect = Rect();
  }
  
  inline LBPEvaluator::OptFeature :: OptFeature()
  {
! for( int i = 0; i < 16; i+=1 )
! ofs[i] = cascadedetecthpp_INTEGER_431_1_16;
  }
  
  inline int LBPEvaluator::OptFeature :: calc( const int* p ) const
  {
! int cval = CALC_SUM_OFS_( ofs[5], ofs[6], ofs[9], ofs[10], p );
  
! return (CALC_SUM_OFS_( ofs[0], ofs[1], ofs[4], ofs[5], p ) >= cval ? 128 : 0) |   // 0
! (CALC_SUM_OFS_( ofs[1], ofs[2], ofs[5], ofs[6], p ) >= cval ? 64 : 0) |    // 1
! (CALC_SUM_OFS_( ofs[2], ofs[3], ofs[6], ofs[7], p ) >= cval ? 32 : 0) |    // 2
! (CALC_SUM_OFS_( ofs[6], ofs[7], ofs[10], ofs[11], p ) >= cval ? 16 : 0) |  // 5
! (CALC_SUM_OFS_( ofs[10], ofs[11], ofs[14], ofs[15], p ) >= cval ? 8 : 0)|  // 8
! (CALC_SUM_OFS_( ofs[9], ofs[10], ofs[13], ofs[14], p ) >= cval ? 4 : 0)|   // 7
! (CALC_SUM_OFS_( ofs[8], ofs[9], ofs[12], ofs[13], p ) >= cval ? 2 : 0)|    // 6
! (CALC_SUM_OFS_( ofs[4], ofs[5], ofs[8], ofs[9], p ) >= cval ? 1 : 0);
  }
  
  
***************
*** 487,647 ****
  
  template<class FEval>
  inline int predictOrdered( CascadeClassifierImpl& cascade,
!                            Ptr<FeatureEvaluator> &_featureEvaluator, double& sum )
  {
!     int nstages = (int)cascade.data.stages.size();
!     int nodeOfs = 0, leafOfs = 0;
!     FEval& featureEvaluator = (FEval&)*_featureEvaluator;
!     float* cascadeLeaves = &cascade.data.leaves[0];
!     CascadeClassifierImpl::Data::DTreeNode* cascadeNodes = &cascade.data.nodes[0];
!     CascadeClassifierImpl::Data::DTree* cascadeWeaks = &cascade.data.classifiers[0];
!     CascadeClassifierImpl::Data::Stage* cascadeStages = &cascade.data.stages[0];
! 
!     for( int si = 0; si < nstages; si++ )
!     {
!         CascadeClassifierImpl::Data::Stage& stage = cascadeStages[si];
!         int wi, ntrees = stage.ntrees;
!         sum = 0;
! 
!         for( wi = 0; wi < ntrees; wi++ )
!         {
!             CascadeClassifierImpl::Data::DTree& weak = cascadeWeaks[stage.first + wi];
!             int idx = 0, root = nodeOfs;
! 
!             do
!             {
!                 CascadeClassifierImpl::Data::DTreeNode& node = cascadeNodes[root + idx];
!                 double val = featureEvaluator(node.featureIdx);
!                 idx = val < node.threshold ? node.left : node.right;
!             }
!             while( idx > 0 );
!             sum += cascadeLeaves[leafOfs - idx];
!             nodeOfs += weak.nodeCount;
!             leafOfs += weak.nodeCount + 1;
!         }
!         if( sum < stage.threshold )
!             return -si;
!     }
!     return 1;
  }
  
  template<class FEval>
  inline int predictCategorical( CascadeClassifierImpl& cascade,
!                                Ptr<FeatureEvaluator> &_featureEvaluator, double& sum )
  {
!     int nstages = (int)cascade.data.stages.size();
!     int nodeOfs = 0, leafOfs = 0;
!     FEval& featureEvaluator = (FEval&)*_featureEvaluator;
!     size_t subsetSize = (cascade.data.ncategories + 31)/32;
!     int* cascadeSubsets = &cascade.data.subsets[0];
!     float* cascadeLeaves = &cascade.data.leaves[0];
!     CascadeClassifierImpl::Data::DTreeNode* cascadeNodes = &cascade.data.nodes[0];
!     CascadeClassifierImpl::Data::DTree* cascadeWeaks = &cascade.data.classifiers[0];
!     CascadeClassifierImpl::Data::Stage* cascadeStages = &cascade.data.stages[0];
! 
!     for(int si = 0; si < nstages; si++ )
!     {
!         CascadeClassifierImpl::Data::Stage& stage = cascadeStages[si];
!         int wi, ntrees = stage.ntrees;
!         sum = 0;
! 
!         for( wi = 0; wi < ntrees; wi++ )
!         {
!             CascadeClassifierImpl::Data::DTree& weak = cascadeWeaks[stage.first + wi];
!             int idx = 0, root = nodeOfs;
!             do
!             {
!                 CascadeClassifierImpl::Data::DTreeNode& node = cascadeNodes[root + idx];
!                 int c = featureEvaluator(node.featureIdx);
!                 const int* subset = &cascadeSubsets[(root + idx)*subsetSize];
!                 idx = (subset[c>>5] & (1 << (c & 31))) ? node.left : node.right;
!             }
!             while( idx > 0 );
!             sum += cascadeLeaves[leafOfs - idx];
!             nodeOfs += weak.nodeCount;
!             leafOfs += weak.nodeCount + 1;
!         }
!         if( sum < stage.threshold )
!             return -si;
!     }
!     return 1;
  }
  
  template<class FEval>
  inline int predictOrderedStump( CascadeClassifierImpl& cascade,
!                                 Ptr<FeatureEvaluator> &_featureEvaluator, double& sum )
  {
!     CV_Assert(!cascade.data.stumps.empty());
!     FEval& featureEvaluator = (FEval&)*_featureEvaluator;
!     const CascadeClassifierImpl::Data::Stump* cascadeStumps = &cascade.data.stumps[0];
!     const CascadeClassifierImpl::Data::Stage* cascadeStages = &cascade.data.stages[0];
! 
!     int nstages = (int)cascade.data.stages.size();
!     double tmp = 0;
! 
!     for( int stageIdx = 0; stageIdx < nstages; stageIdx++ )
!     {
!         const CascadeClassifierImpl::Data::Stage& stage = cascadeStages[stageIdx];
!         tmp = 0;
! 
!         int ntrees = stage.ntrees;
!         for( int i = 0; i < ntrees; i++ )
!         {
!             const CascadeClassifierImpl::Data::Stump& stump = cascadeStumps[i];
!             double value = featureEvaluator(stump.featureIdx);
!             tmp += value < stump.threshold ? stump.left : stump.right;
!         }
! 
!         if( tmp < stage.threshold )
!         {
!             sum = (double)tmp;
!             return -stageIdx;
!         }
!         cascadeStumps += ntrees;
!     }
  
!     sum = (double)tmp;
!     return 1;
  }
  
  template<class FEval>
  inline int predictCategoricalStump( CascadeClassifierImpl& cascade,
!                                     Ptr<FeatureEvaluator> &_featureEvaluator, double& sum )
  {
!     CV_Assert(!cascade.data.stumps.empty());
!     int nstages = (int)cascade.data.stages.size();
!     FEval& featureEvaluator = (FEval&)*_featureEvaluator;
!     size_t subsetSize = (cascade.data.ncategories + 31)/32;
!     const int* cascadeSubsets = &cascade.data.subsets[0];
!     const CascadeClassifierImpl::Data::Stump* cascadeStumps = &cascade.data.stumps[0];
!     const CascadeClassifierImpl::Data::Stage* cascadeStages = &cascade.data.stages[0];
! 
!     double tmp = 0;
!     for( int si = 0; si < nstages; si++ )
!     {
!         const CascadeClassifierImpl::Data::Stage& stage = cascadeStages[si];
!         int wi, ntrees = stage.ntrees;
!         tmp = 0;
! 
!         for( wi = 0; wi < ntrees; wi++ )
!         {
!             const CascadeClassifierImpl::Data::Stump& stump = cascadeStumps[wi];
!             int c = featureEvaluator(stump.featureIdx);
!             const int* subset = &cascadeSubsets[wi*subsetSize];
!             tmp += (subset[c>>5] & (1 << (c & 31))) ? stump.left : stump.right;
!         }
! 
!         if( tmp < stage.threshold )
!         {
!             sum = tmp;
!             return -si;
!         }
! 
!         cascadeStumps += ntrees;
!         cascadeSubsets += ntrees*subsetSize;
!     }
  
!     sum = (double)tmp;
!     return 1;
  }
  }
--- 451,611 ----
  
  template<class FEval>
  inline int predictOrdered( CascadeClassifierImpl& cascade,
! Ptr<FeatureEvaluator> &_featureEvaluator, double& sum )
! {
! int nstages = (int)cascade.data.stages.size();
! int nodeOfs = 0, leafOfs = 0;
! FEval& featureEvaluator = (FEval&)*_featureEvaluator;
! float* cascadeLeaves = &cascade.data.leaves[0];
! CascadeClassifierImpl::Data::DTreeNode* cascadeNodes = &cascade.data.nodes[0];
! CascadeClassifierImpl::Data::DTree* cascadeWeaks = &cascade.data.classifiers[0];
! CascadeClassifierImpl::Data::Stage* cascadeStages = &cascade.data.stages[0];
! 
! for( int si = 0; si < nstages; si+=1 )
! {
! CascadeClassifierImpl::Data::Stage& stage = cascadeStages[si];
! int wi, ntrees = stage.ntrees;
! sum = cascadedetecthpp_INTEGER_467_1_0;
! 
! for( wi = 0; wi < ntrees; wi+=1 )
  {
! CascadeClassifierImpl::Data::DTree& weak = cascadeWeaks[stage.first + wi];
! int idx = 0, root = nodeOfs;
! 
! do
! {
! CascadeClassifierImpl::Data::DTreeNode& node = cascadeNodes[root + idx];
! double val = featureEvaluator(node.featureIdx);
! idx = val < node.threshold ? node.left : node.right;
! }
! while( idx > cascadedetecthpp_INTEGER_480_1_9 );
! sum += cascadeLeaves[leafOfs - idx];
! nodeOfs += weak.nodeCount;
! leafOfs += weak.nodeCount + 1;
! }
! if( sum < stage.threshold )
! return -si;
! }
! return 1;
  }
  
  template<class FEval>
  inline int predictCategorical( CascadeClassifierImpl& cascade,
! Ptr<FeatureEvaluator> &_featureEvaluator, double& sum )
  {
! int nstages = (int)cascade.data.stages.size();
! int nodeOfs = cascadedetecthpp_INTEGER_496_1_0, leafOfs = 0;
! FEval& featureEvaluator = (FEval&)*_featureEvaluator;
! size_t subsetSize = (cascade.data.ncategories + cascadedetecthpp_INTEGER_498_1_0)/32;
! int* cascadeSubsets = &cascade.data.subsets[0];
! float* cascadeLeaves = &cascade.data.leaves[cascadedetecthpp_INTEGER_500_1_0];
! CascadeClassifierImpl::Data::DTreeNode* cascadeNodes = &cascade.data.nodes[0];
! CascadeClassifierImpl::Data::DTree* cascadeWeaks = &cascade.data.classifiers[0];
! CascadeClassifierImpl::Data::Stage* cascadeStages = &cascade.data.stages[0];
! 
! for(int si = 0; si < nstages; si+=1 )
! {
! CascadeClassifierImpl::Data::Stage& stage = cascadeStages[si];
! int wi, ntrees = stage.ntrees;
! sum = cascadedetecthpp_INTEGER_509_1_0;
! 
! for( wi = 0; wi < ntrees; wi+=1 )
! {
! CascadeClassifierImpl::Data::DTree& weak = cascadeWeaks[stage.first + wi];
! int idx = 0, root = nodeOfs;
! do
! {
! CascadeClassifierImpl::Data::DTreeNode& node = cascadeNodes[root + idx];
! int c = featureEvaluator(node.featureIdx);
! const int* subset = &cascadeSubsets[(root + idx)*subsetSize];
! idx = (subset[c>>cascadedetecthpp_INTEGER_520_1_1] & (1 << (c & 31))) ? node.left : node.right;
! }
! while( idx > 0 );
! sum += cascadeLeaves[leafOfs - idx];
! nodeOfs += weak.nodeCount;
! leafOfs += weak.nodeCount + cascadedetecthpp_INTEGER_525_1_1;
! }
! if( sum < stage.threshold )
! return -si;
! }
! return 1;
  }
  
  template<class FEval>
  inline int predictOrderedStump( CascadeClassifierImpl& cascade,
! Ptr<FeatureEvaluator> &_featureEvaluator, double& sum )
! {
! CV_Assert(!cascade.data.stumps.empty());
! FEval& featureEvaluator = (FEval&)*_featureEvaluator;
! const CascadeClassifierImpl::Data::Stump* cascadeStumps = &cascade.data.stumps[cascadedetecthpp_INTEGER_539_1_0];
! const CascadeClassifierImpl::Data::Stage* cascadeStages = &cascade.data.stages[cascadedetecthpp_INTEGER_540_1_0];
! 
! int nstages = (int)cascade.data.stages.size();
! double tmp = 0;
! 
! for( int stageIdx = 0; stageIdx < nstages; stageIdx+=1 )
! {
! const CascadeClassifierImpl::Data::Stage& stage = cascadeStages[stageIdx];
! tmp = cascadedetecthpp_INTEGER_548_1_0;
! 
! int ntrees = stage.ntrees;
! for( int i = cascadedetecthpp_INTEGER_551_1_0; i < ntrees; i+=1 )
! {
! const CascadeClassifierImpl::Data::Stump& stump = cascadeStumps[i];
! double value = featureEvaluator(stump.featureIdx);
! tmp += value < stump.threshold ? stump.left : stump.right;
! }
! 
! if( tmp < stage.threshold )
  {
! sum = (double)tmp;
! return -stageIdx;
! }
! cascadeStumps += ntrees;
! }
  
! sum = (double)tmp;
! return cascadedetecthpp_INTEGER_567_1_1;
  }
  
  template<class FEval>
  inline int predictCategoricalStump( CascadeClassifierImpl& cascade,
! Ptr<FeatureEvaluator> &_featureEvaluator, double& sum )
! {
! CV_Assert(!cascade.data.stumps.empty());
! int nstages = (int)cascade.data.stages.size();
! FEval& featureEvaluator = (FEval&)*_featureEvaluator;
! size_t subsetSize = (cascade.data.ncategories + cascadedetecthpp_INTEGER_577_1_0)/32;
! const int* cascadeSubsets = &cascade.data.subsets[0];
! const CascadeClassifierImpl::Data::Stump* cascadeStumps = &cascade.data.stumps[0];
! const CascadeClassifierImpl::Data::Stage* cascadeStages = &cascade.data.stages[cascadedetecthpp_INTEGER_580_1_0];
! 
! double tmp = cascadedetecthpp_INTEGER_582_1_0;
! for( int si = 0; si < nstages; si+=1 )
! {
! const CascadeClassifierImpl::Data::Stage& stage = cascadeStages[si];
! int wi, ntrees = stage.ntrees;
! tmp = 0;
! 
! for( wi = 0; wi < ntrees; wi+=1 )
  {
! const CascadeClassifierImpl::Data::Stump& stump = cascadeStumps[wi];
! int c = featureEvaluator(stump.featureIdx);
! const int* subset = &cascadeSubsets[wi*subsetSize];
! tmp += (subset[c>>5] & (1 << (c & 31))) ? stump.left : stump.right;
! }
! 
! if( tmp < stage.threshold )
! {
! sum = tmp;
! return -si;
! }
! 
! cascadeStumps += ntrees;
! cascadeSubsets += ntrees*subsetSize;
! }
  
! sum = (double)tmp;
! return 1;
  }
  }
Common subdirectories: ../opencv_unmod/modules/objdetect/src/opencl and ../opencv/modules/objdetect/src/opencl
diff -cN ../opencv_unmod/modules/objdetect/src/replaces.hpp ../opencv/modules/objdetect/src/replaces.hpp
*** ../opencv_unmod/modules/objdetect/src/replaces.hpp	1970-01-01 00:00:00.000000000 +0000
--- ../opencv/modules/objdetect/src/replaces.hpp	2016-04-29 01:01:44.499389999 +0000
***************
*** 0 ****
--- 1,537 ----
+ #define cascadedetectcpp_INTEGER_1654_1_0 0
+ #define cascadedetectcpp_INTEGER_1641_2_0 0
+ #define cascadedetectcpp_INTEGER_1641_1_0 0
+ #define cascadedetectcpp_INTEGER_1620_1_1 1
+ #define cascadedetectcpp_INTEGER_1612_1_0 0
+ #define cascadedetectcpp_INTEGER_1609_2_1 1
+ #define cascadedetectcpp_INTEGER_1609_1_0 0
+ #define cascadedetectcpp_INTEGER_1599_2_0 0
+ #define cascadedetectcpp_INTEGER_1599_1_0 0
+ #define cascadedetectcpp_INTEGER_1598_1_0 0
+ #define cascadedetectcpp_INTEGER_1522_1_1 1
+ #define cascadedetectcpp_INTEGER_1518_4_2 2
+ #define cascadedetectcpp_INTEGER_1518_3_1 1
+ #define cascadedetectcpp_INTEGER_1518_2_1 1
+ #define cascadedetectcpp_INTEGER_1518_1_0 0
+ #define cascadedetectcpp_INTEGER_1513_2_1 1
+ #define cascadedetectcpp_INTEGER_1513_1_0 0
+ #define cascadedetectcpp_INTEGER_1511_2_0 0
+ #define cascadedetectcpp_INTEGER_1511_1_0 0
+ #define cascadedetectcpp_INTEGER_1509_1_1 1
+ #define cascadedetectcpp_INTEGER_1491_2_1 1
+ #define cascadedetectcpp_INTEGER_1491_1_0 0
+ #define cascadedetectcpp_INTEGER_1489_1_0 0
+ #define cascadedetectcpp_INTEGER_1478_1_0 0
+ #define cascadedetectcpp_INTEGER_1447_2_1 1
+ #define cascadedetectcpp_INTEGER_1447_1_0 0
+ #define cascadedetectcpp_INTEGER_1445_1_0 0
+ #define cascadedetectcpp_INTEGER_1431_3_1 1
+ #define cascadedetectcpp_INTEGER_1431_2_0 0
+ #define cascadedetectcpp_INTEGER_1431_1_3 3
+ #define cascadedetectcpp_INTEGER_1430_2_32 32
+ #define cascadedetectcpp_INTEGER_1430_1_31 31
+ #define cascadedetectcpp_INTEGER_1422_2_0 0
+ #define cascadedetectcpp_INTEGER_1422_1_0 0
+ #define cascadedetectcpp_INTEGER_1393_1_0 0
+ #define cascadedetectcpp_INTEGER_1367_1_1 1
+ #define cascadedetectcpp_INTEGER_1323_1_1 1
+ #define cascadedetectcpp_INTEGER_1311_1_0 0
+ #define cascadedetectcpp_INTEGER_1305_2_1 1
+ #define cascadedetectcpp_INTEGER_1305_1_1 1
+ #define cascadedetectcpp_INTEGER_1302_2_1 1
+ #define cascadedetectcpp_INTEGER_1302_1_0 0
+ #define cascadedetectcpp_INTEGER_1299_1_0 0
+ #define cascadedetectcpp_INTEGER_1279_1_0 0
+ #define cascadedetectcpp_INTEGER_1266_1_1 1
+ #define cascadedetectcpp_INTEGER_1264_1_1024 1024
+ #define cascadedetectcpp_INTEGER_1254_1_1 1
+ #define cascadedetectcpp_INTEGER_1244_1_1 1
+ #define cascadedetectcpp_INTEGER_1234_1_0 0
+ #define cascadedetectcpp_INTEGER_1229_2_0 0
+ #define cascadedetectcpp_INTEGER_1229_1_0 0
+ #define cascadedetectcpp_INTEGER_1205_1_0 0
+ #define cascadedetectcpp_INTEGER_1167_2_3 3
+ #define cascadedetectcpp_INTEGER_1167_1_3 3
+ #define cascadedetectcpp_INTEGER_1166_2_2 2
+ #define cascadedetectcpp_INTEGER_1166_1_3 3
+ #define cascadedetectcpp_INTEGER_1165_2_1 1
+ #define cascadedetectcpp_INTEGER_1165_1_3 3
+ #define cascadedetectcpp_INTEGER_1163_2_1 1
+ #define cascadedetectcpp_INTEGER_1163_1_0 0
+ #define cascadedetectcpp_INTEGER_1160_1_0 0
+ #define cascadedetectcpp_INTEGER_1153_1_2 2
+ #define cascadedetectcpp_INTEGER_1142_1_2 2
+ #define cascadedetectcpp_INTEGER_1141_1_1 1
+ #define cascadedetectcpp_INTEGER_1140_1_0 0
+ #define cascadedetectcpp_INTEGER_1138_2_32 32
+ #define cascadedetectcpp_INTEGER_1138_1_31 31
+ #define cascadedetectcpp_INTEGER_1117_1_1 1
+ #define cascadedetectcpp_INTEGER_1113_1_2 2
+ #define cascadedetectcpp_INTEGER_1104_1_2 2
+ #define cascadedetectcpp_INTEGER_1103_1_1 1
+ #define cascadedetectcpp_INTEGER_1102_1_0 0
+ #define cascadedetectcpp_INTEGER_1076_1_1 1
+ #define cascadedetectcpp_INTEGER_1061_1_0 0
+ #define cascadedetectcpp_INTEGER_1060_4_1 1
+ #define cascadedetectcpp_INTEGER_1060_3_1 1
+ #define cascadedetectcpp_INTEGER_1060_2_0 0
+ #define cascadedetectcpp_INTEGER_1060_1_0 0
+ #define cascadedetectcpp_INTEGER_1059_3_1 1
+ #define cascadedetectcpp_INTEGER_1059_2_3 3
+ #define cascadedetectcpp_INTEGER_1059_1_1 1
+ #define cascadedetectcpp_INTEGER_1056_2_1 1
+ #define cascadedetectcpp_INTEGER_1056_1_0 0
+ #define cascadedetectcpp_INTEGER_1055_1_12 12
+ #define cascadedetectcpp_INTEGER_1051_1_0 0
+ #define cascadedetectcpp_INTEGER_1020_1_0 0
+ #define cascadedetectcpp_INTEGER_1012_1_0 0
+ #define cascadedetectcpp_INTEGER_1001_1_0 0
+ #define cascadedetectcpp_INTEGER_999_1_1 1
+ #define cascadedetectcpp_INTEGER_994_1_0 0
+ #define cascadedetectcpp_INTEGER_980_2_1 1
+ #define cascadedetectcpp_INTEGER_980_1_0 3
+ #define cascadedetectcpp_INTEGER_969_1_0 0
+ #define cascadedetectcpp_INTEGER_968_1_0 0
+ #define cascadedetectcpp_INTEGER_931_1_2 2
+ #define cascadedetectcpp_INTEGER_922_1_2 2
+ #define cascadedetectcpp_INTEGER_915_1_1 1
+ #define cascadedetectcpp_INTEGER_914_1_1 1
+ #define cascadedetectcpp_INTEGER_897_3_0 0
+ #define cascadedetectcpp_INTEGER_897_2_0 0
+ #define cascadedetectcpp_INTEGER_897_1_0 0
+ #define cascadedetectcpp_INTEGER_850_2_0 0
+ #define cascadedetectcpp_INTEGER_850_1_0 0
+ #define cascadedetectcpp_INTEGER_847_1_0 0
+ #define cascadedetectcpp_INTEGER_841_5_0 0
+ #define cascadedetectcpp_INTEGER_841_4_13 13
+ #define cascadedetectcpp_INTEGER_841_3_12 12
+ #define cascadedetectcpp_INTEGER_841_2_9 9
+ #define cascadedetectcpp_INTEGER_841_1_8 8
+ #define cascadedetectcpp_INTEGER_840_1_2 2
+ #define cascadedetectcpp_INTEGER_839_5_0 0
+ #define cascadedetectcpp_INTEGER_839_4_15 15
+ #define cascadedetectcpp_INTEGER_839_3_14 14
+ #define cascadedetectcpp_INTEGER_839_2_11 11
+ #define cascadedetectcpp_INTEGER_839_1_10 10
+ #define cascadedetectcpp_INTEGER_838_1_2 2
+ #define cascadedetectcpp_INTEGER_837_5_0 0
+ #define cascadedetectcpp_INTEGER_837_4_7 7
+ #define cascadedetectcpp_INTEGER_837_3_6 6
+ #define cascadedetectcpp_INTEGER_837_2_3 3
+ #define cascadedetectcpp_INTEGER_837_1_2 2
+ #define cascadedetectcpp_INTEGER_836_1_2 2
+ #define cascadedetectcpp_INTEGER_835_5_0 0
+ #define cascadedetectcpp_INTEGER_835_4_5 5
+ #define cascadedetectcpp_INTEGER_835_3_4 4
+ #define cascadedetectcpp_INTEGER_835_2_1 1
+ #define cascadedetectcpp_INTEGER_835_1_0 0
+ #define cascadedetectcpp_INTEGER_823_2_1 1
+ #define cascadedetectcpp_INTEGER_823_1_0 0
+ #define cascadedetectcpp_INTEGER_822_1_0 0
+ #define cascadedetectcpp_INTEGER_785_2_8 8
+ #define cascadedetectcpp_INTEGER_785_1_8 8
+ #define cascadedetectcpp_INTEGER_783_2_0 0
+ #define cascadedetectcpp_INTEGER_783_1_0 0
+ #define cascadedetectcpp_INTEGER_782_1_1 1
+ #define cascadedetectcpp_INTEGER_777_2_1 1
+ #define cascadedetectcpp_INTEGER_777_1_0 0
+ #define cascadedetectcpp_INTEGER_774_1_0 0
+ #define cascadedetectcpp_INTEGER_728_10_2 2
+ #define cascadedetectcpp_INTEGER_728_9_0 0
+ #define cascadedetectcpp_INTEGER_728_8_3 3
+ #define cascadedetectcpp_INTEGER_728_7_2 2
+ #define cascadedetectcpp_INTEGER_728_6_2 2
+ #define cascadedetectcpp_INTEGER_728_5_2 2
+ #define cascadedetectcpp_INTEGER_728_4_1 1
+ #define cascadedetectcpp_INTEGER_728_3_2 2
+ #define cascadedetectcpp_INTEGER_728_2_0 0
+ #define cascadedetectcpp_INTEGER_728_1_2 2
+ #define cascadedetectcpp_INTEGER_727_10_1 1
+ #define cascadedetectcpp_INTEGER_727_9_0 0
+ #define cascadedetectcpp_INTEGER_727_8_3 3
+ #define cascadedetectcpp_INTEGER_727_7_1 1
+ #define cascadedetectcpp_INTEGER_727_6_2 2
+ #define cascadedetectcpp_INTEGER_727_5_1 1
+ #define cascadedetectcpp_INTEGER_727_4_1 1
+ #define cascadedetectcpp_INTEGER_727_3_1 1
+ #define cascadedetectcpp_INTEGER_727_2_0 0
+ #define cascadedetectcpp_INTEGER_727_1_1 1
+ #define cascadedetectcpp_INTEGER_726_10_0 0
+ #define cascadedetectcpp_INTEGER_726_9_0 0
+ #define cascadedetectcpp_INTEGER_726_8_3 3
+ #define cascadedetectcpp_INTEGER_726_7_0 0
+ #define cascadedetectcpp_INTEGER_726_6_2 2
+ #define cascadedetectcpp_INTEGER_726_5_0 0
+ #define cascadedetectcpp_INTEGER_726_4_1 1
+ #define cascadedetectcpp_INTEGER_726_3_0 0
+ #define cascadedetectcpp_INTEGER_726_2_0 0
+ #define cascadedetectcpp_INTEGER_726_1_0 0
+ #define cascadedetectcpp_INTEGER_722_9_2 2
+ #define cascadedetectcpp_INTEGER_722_8_3 3
+ #define cascadedetectcpp_INTEGER_722_7_2 2
+ #define cascadedetectcpp_INTEGER_722_6_2 2
+ #define cascadedetectcpp_INTEGER_722_5_2 2
+ #define cascadedetectcpp_INTEGER_722_4_1 1
+ #define cascadedetectcpp_INTEGER_722_3_2 2
+ #define cascadedetectcpp_INTEGER_722_2_0 0
+ #define cascadedetectcpp_INTEGER_722_1_2 2
+ #define cascadedetectcpp_INTEGER_721_9_1 1
+ #define cascadedetectcpp_INTEGER_721_8_3 3
+ #define cascadedetectcpp_INTEGER_721_7_1 1
+ #define cascadedetectcpp_INTEGER_721_6_2 2
+ #define cascadedetectcpp_INTEGER_721_5_1 1
+ #define cascadedetectcpp_INTEGER_721_4_1 1
+ #define cascadedetectcpp_INTEGER_721_3_1 1
+ #define cascadedetectcpp_INTEGER_721_2_0 0
+ #define cascadedetectcpp_INTEGER_721_1_1 1
+ #define cascadedetectcpp_INTEGER_720_9_0 0
+ #define cascadedetectcpp_INTEGER_720_8_3 3
+ #define cascadedetectcpp_INTEGER_720_7_0 0
+ #define cascadedetectcpp_INTEGER_720_6_2 2
+ #define cascadedetectcpp_INTEGER_720_5_0 0
+ #define cascadedetectcpp_INTEGER_720_4_1 1
+ #define cascadedetectcpp_INTEGER_720_3_0 0
+ #define cascadedetectcpp_INTEGER_720_2_0 0
+ #define cascadedetectcpp_INTEGER_720_1_0 0
+ #define cascadedetectcpp_INTEGER_716_2_2 2
+ #define cascadedetectcpp_INTEGER_716_1_2 2
+ #define cascadedetectcpp_INTEGER_715_2_1 1
+ #define cascadedetectcpp_INTEGER_715_1_1 1
+ #define cascadedetectcpp_INTEGER_714_2_0 0
+ #define cascadedetectcpp_INTEGER_714_1_0 0
+ #define cascadedetectcpp_INTEGER_686_2_0 0
+ #define cascadedetectcpp_INTEGER_686_1_0 0
+ #define cascadedetectcpp_INTEGER_677_1_0 0
+ #define cascadedetectcpp_INTEGER_676_2_1 1
+ #define cascadedetectcpp_INTEGER_676_1_0 0
+ #define cascadedetectcpp_INTEGER_672_2_1 1
+ #define cascadedetectcpp_INTEGER_672_1_0 0
+ #define cascadedetectcpp_INTEGER_671_1_0 0
+ #define cascadedetectcpp_INTEGER_666_5_0 0
+ #define cascadedetectcpp_INTEGER_666_4_3 3
+ #define cascadedetectcpp_INTEGER_666_3_2 2
+ #define cascadedetectcpp_INTEGER_666_2_1 1
+ #define cascadedetectcpp_INTEGER_666_1_0 0
+ #define cascadedetectcpp_INTEGER_621_1_2 2
+ #define cascadedetectcpp_INTEGER_603_2_0 0
+ #define cascadedetectcpp_INTEGER_603_1_0 0
+ #define cascadedetectcpp_INTEGER_602_1_1024 1024
+ #define cascadedetectcpp_INTEGER_599_2_8 8
+ #define cascadedetectcpp_INTEGER_599_1_8 8
+ #define cascadedetectcpp_INTEGER_594_2_0 0
+ #define cascadedetectcpp_INTEGER_594_1_0 0
+ #define cascadedetectcpp_INTEGER_592_4_2 2
+ #define cascadedetectcpp_INTEGER_592_3_2 2
+ #define cascadedetectcpp_INTEGER_592_2_1 1
+ #define cascadedetectcpp_INTEGER_592_1_1 1
+ #define cascadedetectcpp_INTEGER_591_2_2 2
+ #define cascadedetectcpp_INTEGER_591_1_3 3
+ #define cascadedetectcpp_INTEGER_584_2_1 1
+ #define cascadedetectcpp_INTEGER_584_1_0 0
+ #define cascadedetectcpp_INTEGER_570_1_0 0
+ #define cascadedetectcpp_INTEGER_558_1_0 0
+ #define cascadedetectcpp_INTEGER_557_1_0 0
+ #define cascadedetectcpp_INTEGER_556_2_0 0
+ #define cascadedetectcpp_INTEGER_556_1_0 0
+ #define cascadedetectcpp_INTEGER_555_2_2 2
+ #define cascadedetectcpp_INTEGER_555_1_4 4
+ #define cascadedetectcpp_INTEGER_554_1_0 0
+ #define cascadedetectcpp_INTEGER_553_1_0 0
+ #define cascadedetectcpp_INTEGER_547_1_0 0
+ #define cascadedetectcpp_INTEGER_540_2_1 1
+ #define cascadedetectcpp_INTEGER_540_1_0 0
+ #define cascadedetectcpp_INTEGER_534_2_1 1
+ #define cascadedetectcpp_INTEGER_534_1_0 0
+ #define cascadedetectcpp_INTEGER_516_2_1 1
+ #define cascadedetectcpp_INTEGER_516_1_1 1
+ #define cascadedetectcpp_INTEGER_513_2_1 1
+ #define cascadedetectcpp_INTEGER_513_1_0 0
+ #define cascadedetectcpp_INTEGER_501_4_1 1
+ #define cascadedetectcpp_INTEGER_501_3_1 1
+ #define cascadedetectcpp_INTEGER_501_2_0 0
+ #define cascadedetectcpp_INTEGER_501_1_0 0
+ #define cascadedetectcpp_INTEGER_498_2_1 1
+ #define cascadedetectcpp_INTEGER_498_1_0 0
+ #define cascadedetectcpp_INTEGER_493_1_0 0
+ #define cascadedetectcpp_INTEGER_485_1_16 16
+ #define cascadedetectcpp_INTEGER_484_1_0 0
+ #define cascadedetectcpp_INTEGER_480_1_0 0
+ #define cascadedetectcpp_INTEGER_460_1_0 0
+ #define cascadedetectcpp_INTEGER_453_1_0 0
+ #define cascadedetectcpp_INTEGER_451_2_1 1
+ #define cascadedetectcpp_INTEGER_451_1_1 1
+ #define cascadedetectcpp_INTEGER_449_3_2 2
+ #define cascadedetectcpp_INTEGER_449_2_1 1
+ #define cascadedetectcpp_INTEGER_449_1_2 2
+ #define cascadedetectcpp_INTEGER_443_1_100 100
+ #define cascadedetectcpp_INTEGER_440_2_1 1
+ #define cascadedetectcpp_INTEGER_440_1_0 0
+ #define cascadedetectcpp_INTEGER_437_3_32 32
+ #define cascadedetectcpp_INTEGER_437_2_31 31
+ #define cascadedetectcpp_INTEGER_437_1_0 0
+ #define cascadedetectcpp_INTEGER_435_2_0 0
+ #define cascadedetectcpp_INTEGER_435_1_0 0
+ #define cascadedetectcpp_INTEGER_434_1_0 0
+ #define cascadedetectcpp_INTEGER_423_1_0 0
+ #define cascadedetectcpp_INTEGER_397_1_1 1
+ #define cascadedetectcpp_INTEGER_388_2_0 0
+ #define cascadedetectcpp_INTEGER_388_1_0 0
+ #define cascadedetectcpp_INTEGER_367_1_0 0
+ #define cascadedetectcpp_INTEGER_362_2_0 0
+ #define cascadedetectcpp_INTEGER_362_1_0 0
+ #define cascadedetectcpp_INTEGER_349_2_2 2
+ #define cascadedetectcpp_INTEGER_349_1_2 2
+ #define cascadedetectcpp_INTEGER_342_1_0 0
+ #define cascadedetectcpp_INTEGER_340_1_1 1
+ #define cascadedetectcpp_INTEGER_338_1_100 100
+ #define cascadedetectcpp_INTEGER_336_2_16 16
+ #define cascadedetectcpp_INTEGER_336_1_8 8
+ #define cascadedetectcpp_INTEGER_324_2_1 1
+ #define cascadedetectcpp_INTEGER_324_1_0 0
+ #define cascadedetectcpp_INTEGER_291_2_1 1
+ #define cascadedetectcpp_INTEGER_291_1_0 0
+ #define cascadedetectcpp_INTEGER_283_4_1 1
+ #define cascadedetectcpp_INTEGER_283_3_1 1
+ #define cascadedetectcpp_INTEGER_283_2_1 1
+ #define cascadedetectcpp_INTEGER_283_1_2 2
+ #define cascadedetectcpp_INTEGER_269_2_1 1
+ #define cascadedetectcpp_INTEGER_269_1_0 0
+ #define cascadedetectcpp_INTEGER_268_1_0 0
+ #define cascadedetectcpp_INTEGER_252_4_1 1
+ #define cascadedetectcpp_INTEGER_252_3_1 1
+ #define cascadedetectcpp_INTEGER_252_2_1 1
+ #define cascadedetectcpp_INTEGER_252_1_2 2
+ #define cascadedetectcpp_INTEGER_235_2_1 1
+ #define cascadedetectcpp_INTEGER_235_1_0 0
+ #define cascadedetectcpp_INTEGER_213_2_1 1
+ #define cascadedetectcpp_INTEGER_213_1_0 0
+ #define cascadedetectcpp_INTEGER_197_2_1 1
+ #define cascadedetectcpp_INTEGER_197_1_0 0
+ #define cascadedetectcpp_INTEGER_194_2_1 1
+ #define cascadedetectcpp_INTEGER_194_1_0 0
+ #define cascadedetectcpp_INTEGER_184_2_1 1
+ #define cascadedetectcpp_INTEGER_184_1_0 0
+ #define cascadedetectcpp_INTEGER_173_1_20 20
+ #define cascadedetectcpp_INTEGER_154_2_3 3
+ #define cascadedetectcpp_INTEGER_154_1_3 3
+ #define cascadedetectcpp_INTEGER_138_2_1 1
+ #define cascadedetectcpp_INTEGER_138_1_0 0
+ #define cascadedetectcpp_INTEGER_127_2_1 1
+ #define cascadedetectcpp_INTEGER_127_1_0 0
+ #define cascadedetectcpp_INTEGER_111_2_1 1
+ #define cascadedetectcpp_INTEGER_111_1_0 0
+ #define cascadedetectcpp_INTEGER_96_2_1 1
+ #define cascadedetectcpp_INTEGER_96_1_0 0
+ #define cascadedetectcpp_INTEGER_89_1_1 1
+ #define cascadedetectcpp_INTEGER_82_2_1 1
+ #define cascadedetectcpp_INTEGER_82_1_0 0
+ #define cascadedetectcpp_INTEGER_79_1_0 0
+ #define cascadedetectcpp_INTEGER_78_1_0 0
+ #define cascadedetectcpp_INTEGER_69_1_1 1
+ #define cascadedetectcpp_INTEGER_68_2_1 1
+ #define cascadedetectcpp_INTEGER_68_1_0 0
+ #define cascadedetectcpp_INTEGER_62_1_0 0
+ #define cascadedetectcpp_INTEGER_56_3_0 0
+ #define cascadedetectcpp_INTEGER_56_2_0 0
+ #define cascadedetectcpp_INTEGER_56_1_1 1
+ #define cascadedetectcpp_INTEGER_13_2_2013 2013
+ #define cascadedetectcpp_INTEGER_13_1_2008 2008
+ #define cascadedetecthpp_INTEGER_645_1_1 1
+ #define cascadedetecthpp_INTEGER_631_3_31 31
+ #define cascadedetecthpp_INTEGER_631_2_1 1
+ #define cascadedetecthpp_INTEGER_631_1_5 5
+ #define cascadedetecthpp_INTEGER_626_2_1 1
+ #define cascadedetecthpp_INTEGER_626_1_0 0
+ #define cascadedetecthpp_INTEGER_624_1_0 0
+ #define cascadedetecthpp_INTEGER_620_2_1 1
+ #define cascadedetecthpp_INTEGER_620_1_0 0
+ #define cascadedetecthpp_INTEGER_619_1_0 0
+ #define cascadedetecthpp_INTEGER_617_1_0 0
+ #define cascadedetecthpp_INTEGER_616_1_0 0
+ #define cascadedetecthpp_INTEGER_615_1_0 0
+ #define cascadedetecthpp_INTEGER_614_2_32 32
+ #define cascadedetecthpp_INTEGER_614_1_31 31
+ #define cascadedetecthpp_INTEGER_604_1_1 1
+ #define cascadedetecthpp_INTEGER_588_2_1 1
+ #define cascadedetecthpp_INTEGER_588_1_0 0
+ #define cascadedetecthpp_INTEGER_585_1_0 0
+ #define cascadedetecthpp_INTEGER_582_2_1 1
+ #define cascadedetecthpp_INTEGER_582_1_0 0
+ #define cascadedetecthpp_INTEGER_580_1_0 0
+ #define cascadedetecthpp_INTEGER_577_1_0 0
+ #define cascadedetecthpp_INTEGER_576_1_0 0
+ #define cascadedetecthpp_INTEGER_567_1_1 1
+ #define cascadedetecthpp_INTEGER_562_1_1 1
+ #define cascadedetecthpp_INTEGER_559_1_0 0
+ #define cascadedetecthpp_INTEGER_557_3_31 31
+ #define cascadedetecthpp_INTEGER_557_2_1 1
+ #define cascadedetecthpp_INTEGER_557_1_5 5
+ #define cascadedetecthpp_INTEGER_551_1_0 0
+ #define cascadedetecthpp_INTEGER_548_2_1 1
+ #define cascadedetecthpp_INTEGER_548_1_0 0
+ #define cascadedetecthpp_INTEGER_546_1_0 0
+ #define cascadedetecthpp_INTEGER_542_2_1 1
+ #define cascadedetecthpp_INTEGER_542_1_0 0
+ #define cascadedetecthpp_INTEGER_540_1_0 0
+ #define cascadedetecthpp_INTEGER_539_1_0 0
+ #define cascadedetecthpp_INTEGER_538_1_0 0
+ #define cascadedetecthpp_INTEGER_537_1_0 0
+ #define cascadedetecthpp_INTEGER_536_1_0 0
+ #define cascadedetecthpp_INTEGER_535_2_32 32
+ #define cascadedetecthpp_INTEGER_535_1_31 31
+ #define cascadedetecthpp_INTEGER_533_2_0 0
+ #define cascadedetecthpp_INTEGER_533_1_0 0
+ #define cascadedetecthpp_INTEGER_525_1_1 1
+ #define cascadedetecthpp_INTEGER_520_1_1 1
+ #define cascadedetecthpp_INTEGER_517_1_0 0
+ #define cascadedetecthpp_INTEGER_509_1_0 0
+ #define cascadedetecthpp_INTEGER_506_2_1 1
+ #define cascadedetecthpp_INTEGER_506_1_0 0
+ #define cascadedetecthpp_INTEGER_504_1_0 0
+ #define cascadedetecthpp_INTEGER_500_2_1 1
+ #define cascadedetecthpp_INTEGER_500_1_0 0
+ #define cascadedetecthpp_INTEGER_498_1_0 0
+ #define cascadedetecthpp_INTEGER_497_1_0 0
+ #define cascadedetecthpp_INTEGER_496_1_0 0
+ #define cascadedetecthpp_INTEGER_495_1_0 0
+ #define cascadedetecthpp_INTEGER_493_2_0 0
+ #define cascadedetecthpp_INTEGER_493_1_0 0
+ #define cascadedetecthpp_INTEGER_482_6_0 0
+ #define cascadedetecthpp_INTEGER_482_5_1 1
+ #define cascadedetecthpp_INTEGER_482_4_9 9
+ #define cascadedetecthpp_INTEGER_482_3_8 8
+ #define cascadedetecthpp_INTEGER_482_2_5 5
+ #define cascadedetecthpp_INTEGER_482_1_4 4
+ #define cascadedetecthpp_INTEGER_481_7_6 6
+ #define cascadedetecthpp_INTEGER_481_6_0 0
+ #define cascadedetecthpp_INTEGER_481_5_2 2
+ #define cascadedetecthpp_INTEGER_481_4_13 13
+ #define cascadedetecthpp_INTEGER_481_3_12 12
+ #define cascadedetecthpp_INTEGER_481_2_9 9
+ #define cascadedetecthpp_INTEGER_481_1_8 8
+ #define cascadedetecthpp_INTEGER_480_7_7 7
+ #define cascadedetecthpp_INTEGER_480_6_0 0
+ #define cascadedetecthpp_INTEGER_480_5_4 4
+ #define cascadedetecthpp_INTEGER_480_4_14 14
+ #define cascadedetecthpp_INTEGER_480_3_13 13
+ #define cascadedetecthpp_INTEGER_480_2_10 10
+ #define cascadedetecthpp_INTEGER_480_1_9 9
+ #define cascadedetecthpp_INTEGER_479_7_8 8
+ #define cascadedetecthpp_INTEGER_479_6_0 0
+ #define cascadedetecthpp_INTEGER_479_5_8 8
+ #define cascadedetecthpp_INTEGER_479_4_15 15
+ #define cascadedetecthpp_INTEGER_479_3_14 14
+ #define cascadedetecthpp_INTEGER_479_2_11 11
+ #define cascadedetecthpp_INTEGER_479_1_10 10
+ #define cascadedetecthpp_INTEGER_478_7_5 5
+ #define cascadedetecthpp_INTEGER_478_6_0 0
+ #define cascadedetecthpp_INTEGER_478_5_16 16
+ #define cascadedetecthpp_INTEGER_478_4_11 11
+ #define cascadedetecthpp_INTEGER_478_3_10 10
+ #define cascadedetecthpp_INTEGER_478_2_7 7
+ #define cascadedetecthpp_INTEGER_478_1_6 6
+ #define cascadedetecthpp_INTEGER_477_7_2 2
+ #define cascadedetecthpp_INTEGER_477_6_0 0
+ #define cascadedetecthpp_INTEGER_477_5_32 32
+ #define cascadedetecthpp_INTEGER_477_4_7 7
+ #define cascadedetecthpp_INTEGER_477_3_6 6
+ #define cascadedetecthpp_INTEGER_477_2_3 3
+ #define cascadedetecthpp_INTEGER_477_1_2 2
+ #define cascadedetecthpp_INTEGER_476_7_1 1
+ #define cascadedetecthpp_INTEGER_476_6_0 0
+ #define cascadedetecthpp_INTEGER_476_5_64 64
+ #define cascadedetecthpp_INTEGER_476_4_6 6
+ #define cascadedetecthpp_INTEGER_476_3_5 5
+ #define cascadedetecthpp_INTEGER_476_2_2 2
+ #define cascadedetecthpp_INTEGER_476_1_1 1
+ #define cascadedetecthpp_INTEGER_475_7_0 0
+ #define cascadedetecthpp_INTEGER_475_6_0 0
+ #define cascadedetecthpp_INTEGER_475_5_128 128
+ #define cascadedetecthpp_INTEGER_475_4_5 5
+ #define cascadedetecthpp_INTEGER_475_3_4 4
+ #define cascadedetecthpp_INTEGER_475_2_1 1
+ #define cascadedetecthpp_INTEGER_475_1_0 0
+ #define cascadedetecthpp_INTEGER_473_4_10 10
+ #define cascadedetecthpp_INTEGER_473_3_9 9
+ #define cascadedetecthpp_INTEGER_473_2_6 6
+ #define cascadedetecthpp_INTEGER_473_1_5 5
+ #define cascadedetecthpp_INTEGER_468_1_0 0
+ #define cascadedetecthpp_INTEGER_467_3_1 1
+ #define cascadedetecthpp_INTEGER_467_2_16 16
+ #define cascadedetecthpp_INTEGER_467_1_0 0
+ #define cascadedetecthpp_INTEGER_431_1_16 16
+ #define cascadedetecthpp_INTEGER_404_2_2 2
+ #define cascadedetecthpp_INTEGER_404_1_2 2
+ #define cascadedetecthpp_INTEGER_403_1_2 2
+ #define cascadedetecthpp_INTEGER_401_2_1 1
+ #define cascadedetecthpp_INTEGER_401_1_1 1
+ #define cascadedetecthpp_INTEGER_400_2_0 0
+ #define cascadedetecthpp_INTEGER_400_1_0 0
+ #define cascadedetecthpp_INTEGER_395_9_0 0
+ #define cascadedetecthpp_INTEGER_395_8_3 3
+ #define cascadedetecthpp_INTEGER_395_7_2 2
+ #define cascadedetecthpp_INTEGER_395_6_2 2
+ #define cascadedetecthpp_INTEGER_395_5_2 2
+ #define cascadedetecthpp_INTEGER_395_4_1 1
+ #define cascadedetecthpp_INTEGER_395_3_2 2
+ #define cascadedetecthpp_INTEGER_395_2_0 0
+ #define cascadedetecthpp_INTEGER_395_1_2 2
+ #define cascadedetecthpp_INTEGER_394_8_3 3
+ #define cascadedetecthpp_INTEGER_394_7_1 1
+ #define cascadedetecthpp_INTEGER_394_6_2 2
+ #define cascadedetecthpp_INTEGER_394_5_1 1
+ #define cascadedetecthpp_INTEGER_394_4_1 1
+ #define cascadedetecthpp_INTEGER_394_3_1 1
+ #define cascadedetecthpp_INTEGER_394_2_0 0
+ #define cascadedetecthpp_INTEGER_394_1_1 1
+ #define cascadedetecthpp_INTEGER_393_8_3 3
+ #define cascadedetecthpp_INTEGER_393_7_0 0
+ #define cascadedetecthpp_INTEGER_393_6_2 2
+ #define cascadedetecthpp_INTEGER_393_5_0 0
+ #define cascadedetecthpp_INTEGER_393_4_1 1
+ #define cascadedetecthpp_INTEGER_393_3_0 0
+ #define cascadedetecthpp_INTEGER_393_2_0 0
+ #define cascadedetecthpp_INTEGER_393_1_0 0
+ #define cascadedetecthpp_INTEGER_391_3_2 2
+ #define cascadedetecthpp_INTEGER_391_2_1 1
+ #define cascadedetecthpp_INTEGER_391_1_0 0
+ #define cascadedetecthpp_INTEGER_386_4_0 0
+ #define cascadedetecthpp_INTEGER_386_3_2 2
+ #define cascadedetecthpp_INTEGER_386_2_1 1
+ #define cascadedetecthpp_INTEGER_386_1_0 0
+ #define cascadedetecthpp_INTEGER_385_3_2 2
+ #define cascadedetecthpp_INTEGER_385_2_1 1
+ #define cascadedetecthpp_INTEGER_385_1_0 0
+ #define cascadedetecthpp_INTEGER_346_1_4 4
+ #define cascadedetecthpp_INTEGER_345_1_4 4
+ #define cascadedetecthpp_INTEGER_329_1_3 3
+ #define cascadedetecthpp_INTEGER_316_4_3 3
+ #define cascadedetecthpp_INTEGER_316_3_2 2
+ #define cascadedetecthpp_INTEGER_316_2_1 1
+ #define cascadedetecthpp_INTEGER_316_1_0 0
+ #define cascadedetecthpp_INTEGER_311_4_3 3
+ #define cascadedetecthpp_INTEGER_311_3_2 2
+ #define cascadedetecthpp_INTEGER_311_2_1 1
+ #define cascadedetecthpp_INTEGER_311_1_0 0
+ #define cascadedetecthpp_INTEGER_285_4_3 3
+ #define cascadedetecthpp_INTEGER_285_3_2 2
+ #define cascadedetecthpp_INTEGER_285_2_1 1
+ #define cascadedetecthpp_INTEGER_285_1_0 0
+ #define cascadedetecthpp_INTEGER_138_1_0 0
+ #define cascadedetecthpp_INTEGER_137_1_10000 10000
+ #define cascadedetecthpp_INTEGER_122_1_64 64
+ #define cascadedetecthpp_INTEGER_107_2_0 0
+ #define cascadedetecthpp_INTEGER_107_1_3 3
+ #define cascadedetecthpp_INTEGER_98_2_0 0
+ #define cascadedetecthpp_INTEGER_98_1_3 3
+ #define cascadedetecthpp_INTEGER_90_2_0 0
+ #define cascadedetecthpp_INTEGER_90_1_3 3
+ #define cascadedetecthpp_INTEGER_61_2_2 2
+ #define cascadedetecthpp_INTEGER_61_1_1 1
+ #define cascadedetecthpp_INTEGER_46_1_0 0
+ #define cascadedetecthpp_INTEGER_27_1_0 0
+ #define cascadedetecthpp_INTEGER_26_1_0 0
+ #define cascadedetecthpp_INTEGER_23_1_0 0
+ #define cascadedetecthpp_INTEGER_18_1_2 2
+ #define cascadedetecthpp_INTEGER_17_1_1 1
+ #define cascadedetecthpp_INTEGER_16_1_0 0
